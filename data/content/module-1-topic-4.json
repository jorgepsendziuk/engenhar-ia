{
  "id": "module-1-topic-4",
  "title": "Criando sua primeira IA do zero",
  "content": "## Introdução\n\nCriar sua primeira rede neural do zero é um marco importante na jornada de aprendizado de Machine Learning. Neste tópico, vamos construir uma rede neural simples em JavaScript usando TensorFlow.js, entendendo cada passo do processo. Isso nos dará uma base sólida para trabalhar com modelos mais complexos no futuro.\n\n## Passo a passo para criar e treinar a primeira rede neural em JavaScript\n\n### Setup Inicial\n\nPrimeiro, vamos configurar nosso ambiente:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Minha Primeira Rede Neural</title>\n    <script src=\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest\"></script>\n</head>\n<body>\n    <h1>Treinando Rede Neural</h1>\n    <div id=\"output\"></div>\n    <script src=\"neural-network.js\"></script>\n</body>\n</html>\n```\n\n### Criando a Rede Neural\n\nVamos criar uma rede neural simples que aprende a função y = 2x + 1:\n\n```javascript\n// neural-network.js\n\n// 1. Definir o modelo\nconst model = tf.sequential({\n    layers: [\n        tf.layers.dense({\n            inputShape: [1],      // Entrada: 1 valor (x)\n            units: 1,             // Saída: 1 valor (y)\n            activation: 'linear'  // Sem ativação (regressão linear)\n        })\n    ]\n});\n\n// 2. Compilar o modelo\nmodel.compile({\n    optimizer: 'sgd',           // Stochastic Gradient Descent\n    loss: 'meanSquaredError',   // Função de erro\n    metrics: ['mse']            // Métrica para monitorar\n});\n\n// 3. Preparar dados de treinamento\n// Entrada: valores de x\nconst xs = tf.tensor2d([\n    [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]\n]);\n\n// Saída esperada: valores de y = 2x + 1\nconst ys = tf.tensor2d([\n    [3], [5], [7], [9], [11], [13], [15], [17], [19], [21]\n]);\n\n// 4. Treinar o modelo\nasync function trainModel() {\n    const history = await model.fit(xs, ys, {\n        epochs: 100,        // Número de iterações\n        batchSize: 10,      // Tamanho do batch\n        callbacks: {\n            onEpochEnd: (epoch, logs) => {\n                console.log(`Época ${epoch}: loss = ${logs.loss.toFixed(4)}`);\n            }\n        }\n    });\n    \n    return history;\n}\n\n// 5. Fazer predições\nasync function predict() {\n    await trainModel();\n    \n    // Testar com novos valores\n    const testX = tf.tensor2d([[11], [12], [13]]);\n    const predictions = model.predict(testX);\n    \n    predictions.print();\n    // Deve prever aproximadamente: [23], [25], [27]\n}\n\npredict();\n```\n\n### Explicação do Código\n\n**1. Definir o Modelo**:\n- `sequential`: Modelo onde camadas são empilhadas sequencialmente\n- `dense`: Camada totalmente conectada (cada neurônio conectado a todos da camada anterior)\n- `inputShape: [1]`: Entrada é um único valor\n- `units: 1`: Uma única saída\n\n**2. Compilar**:\n- `optimizer`: Algoritmo que ajusta os pesos (SGD é simples e eficaz)\n- `loss`: Função que mede o erro (MSE para regressão)\n- `metrics`: Métricas para monitorar durante treinamento\n\n**3. Dados de Treinamento**:\n- `xs`: Valores de entrada (x)\n- `ys`: Valores de saída esperados (y = 2x + 1)\n- Tensores são estruturas de dados do TensorFlow.js\n\n**4. Treinar**:\n- `epochs`: Quantas vezes o modelo vê todos os dados\n- `batchSize`: Quantos exemplos processar de cada vez\n- `callbacks`: Funções chamadas durante treinamento\n\n## Entender o ciclo completo: dados → treino → validação → inferência\n\n### 1. Preparação de Dados\n\n**Coleta**:\n- Obter dados relevantes para o problema\n- Garantir qualidade e quantidade suficientes\n\n**Limpeza**:\n- Remover dados inválidos ou duplicados\n- Tratar valores faltantes\n- Normalizar ou padronizar valores\n\n**Divisão**:\n- **Treino** (70-80%): Dados para o modelo aprender\n- **Validação** (10-15%): Dados para ajustar hiperparâmetros\n- **Teste** (10-15%): Dados para avaliar performance final\n\n**Exemplo**:\n```javascript\n// Dividir dados\nconst [trainXs, testXs] = tf.split(xs, [8, 2]);\nconst [trainYs, testYs] = tf.split(ys, [8, 2]);\n```\n\n### 2. Treinamento (Training)\n\n**Objetivo**: Aprender padrões nos dados de treino\n\n**Processo**:\n1. Modelo faz predições nos dados de treino\n2. Calcula erro (loss)\n3. Ajusta pesos usando backpropagation\n4. Repete até convergir\n\n**Monitoramento**:\n- Loss deve diminuir ao longo do tempo\n- Se aumentar, pode estar overfitting\n- Usar early stopping se necessário\n\n**Exemplo com Validação**:\n```javascript\nconst history = await model.fit(trainXs, trainYs, {\n    epochs: 100,\n    validationSplit: 0.2,  // 20% para validação\n    callbacks: {\n        onEpochEnd: (epoch, logs) => {\n            console.log(`Train loss: ${logs.loss}, Val loss: ${logs.val_loss}`);\n        }\n    }\n});\n```\n\n### 3. Validação (Validation)\n\n**Objetivo**: Ajustar hiperparâmetros e detectar overfitting\n\n**Métricas**:\n- Comparar loss de treino vs validação\n- Se validação para de melhorar, pode estar overfitting\n- Ajustar learning rate, arquitetura, regularização\n\n**Técnicas**:\n- **Cross-validation**: Dividir dados em k folds\n- **Early stopping**: Parar quando validação para de melhorar\n- **Hyperparameter tuning**: Testar diferentes configurações\n\n### 4. Inferência (Prediction)\n\n**Objetivo**: Usar modelo treinado para fazer predições em novos dados\n\n**Processo**:\n1. Carregar modelo treinado\n2. Preparar novos dados (mesmo formato de treino)\n3. Fazer predições\n4. Interpretar resultados\n\n**Exemplo**:\n```javascript\n// Carregar modelo salvo\nconst loadedModel = await tf.loadLayersModel('localstorage://my-model');\n\n// Fazer predição\nconst newData = tf.tensor2d([[15], [20], [25]]);\nconst predictions = loadedModel.predict(newData);\n\n// Converter para array JavaScript\nconst results = await predictions.array();\nconsole.log('Predições:', results);\n```\n\n## Exemplo Completo: Classificação de Imagens Simples\n\nVamos criar um exemplo mais complexo - classificar se um número é par ou ímpar:\n\n```javascript\n// Criar modelo mais complexo\nconst model = tf.sequential({\n    layers: [\n        tf.layers.dense({\n            inputShape: [1],\n            units: 8,\n            activation: 'relu'  // ReLU para não-linearidade\n        }),\n        tf.layers.dense({\n            units: 4,\n            activation: 'relu'\n        }),\n        tf.layers.dense({\n            units: 2,           // 2 classes: par ou ímpar\n            activation: 'softmax'  // Probabilidades\n        })\n    ]\n});\n\nmodel.compile({\n    optimizer: 'adam',\n    loss: 'categoricalCrossentropy',\n    metrics: ['accuracy']\n});\n\n// Dados: números de 0 a 99\nconst numbers = Array.from({length: 100}, (_, i) => i);\nconst xs = tf.tensor2d(numbers.map(n => [n]));\n\n// Labels: [1, 0] para par, [0, 1] para ímpar\nconst ys = tf.tensor2d(\n    numbers.map(n => n % 2 === 0 ? [1, 0] : [0, 1])\n);\n\n// Treinar\nasync function train() {\n    await model.fit(xs, ys, {\n        epochs: 50,\n        batchSize: 32,\n        validationSplit: 0.2,\n        callbacks: {\n            onEpochEnd: (epoch, logs) => {\n                console.log(`Época ${epoch}: acc = ${logs.acc.toFixed(4)}`);\n            }\n        }\n    });\n    \n    // Testar\n    const testNum = tf.tensor2d([[101], [102], [103]]);\n    const pred = model.predict(testNum);\n    pred.print();\n}\n\ntrain();\n```\n\n## Boas Práticas\n\n### 1. Normalização de Dados\n\nSempre normalize dados de entrada:\n```javascript\n// Normalizar para 0-1\nconst min = xs.min();\nconst max = xs.max();\nconst normalized = xs.sub(min).div(max.sub(min));\n```\n\n### 2. Salvando e Carregando Modelos\n\n```javascript\n// Salvar\nawait model.save('localstorage://my-model');\n\n// Carregar\nconst loadedModel = await tf.loadLayersModel('localstorage://my-model');\n```\n\n### 3. Visualização do Treinamento\n\nUse callbacks para visualizar progresso:\n```javascript\ncallbacks: {\n    onEpochEnd: (epoch, logs) => {\n        // Atualizar gráfico ou UI\n        updateChart(epoch, logs.loss, logs.val_loss);\n    }\n}\n```\n\n### 4. Tratamento de Erros\n\n```javascript\ntry {\n    await model.fit(xs, ys, config);\n} catch (error) {\n    console.error('Erro no treinamento:', error);\n}\n```\n\n## Armadilhas Comuns\n\n1. **Overfitting**: Modelo memoriza dados de treino mas não generaliza\n   - **Solução**: Usar validação, regularização, mais dados\n\n2. **Underfitting**: Modelo muito simples para o problema\n   - **Solução**: Aumentar complexidade, mais épocas\n\n3. **Dados não normalizados**: Pode causar problemas de convergência\n   - **Solução**: Sempre normalizar dados\n\n4. **Learning rate muito alto**: Modelo não converge\n   - **Solução**: Reduzir learning rate\n\n## Conclusão\n\nCriar sua primeira rede neural do zero é um passo fundamental. Você agora entende:\n\n- Como estruturar um modelo\n- Como preparar dados\n- Como treinar e validar\n- Como fazer inferências\n- O ciclo completo de ML\n\nNo próximo tópico, vamos explorar projetos práticos usando ML na Web, aplicando esses conceitos em cenários reais!",
  "resources": [
    {
      "type": "code",
      "title": "TensorFlow.js Getting Started",
      "url": "https://www.tensorflow.org/js/guide",
      "description": "Guia oficial de início rápido do TensorFlow.js"
    },
    {
      "type": "code",
      "title": "TensorFlow.js Examples - GitHub",
      "url": "https://github.com/tensorflow/tfjs-examples",
      "description": "Exemplos práticos de modelos em TensorFlow.js"
    },
    {
      "type": "video",
      "title": "TensorFlow.js Crash Course - The Coding Train",
      "url": "https://www.youtube.com/watch?v=Qt3ZABW5lD0",
      "description": "Tutorial em vídeo sobre TensorFlow.js"
    },
    {
      "type": "link",
      "title": "Neural Network Playground",
      "url": "https://playground.tensorflow.org",
      "description": "Ferramenta interativa para visualizar treinamento de redes neurais"
    },
    {
      "type": "code",
      "title": "ML5.js Examples",
      "url": "https://github.com/ml5js/ml5-examples",
      "description": "Exemplos simplificados usando ML5.js"
    }
  ]
}

