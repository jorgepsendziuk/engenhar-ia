{
  "id": "module-3-topic-6",
  "title": "Segurança e governança em MCPs",
  "content": "## Introdução\n\nAo expor serviços internos via MCP para LLMs e agentes, segurança e governança tornam-se críticos. Este tópico cobre autenticação, service tokens, rate limiting, WAF e outras proteções essenciais para garantir que seus MCPs sejam seguros e controlados.\n\n## Autenticação e Service Tokens\n\n### Service Tokens\n\nService tokens são tokens específicos para autenticação de serviços (não usuários):\n\n```typescript\n// src/auth/service-tokens.ts\nimport crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\n\nclass ServiceTokenManager {\n  private secret: string;\n  private tokens: Map<string, ServiceToken> = new Map();\n  \n  constructor(secret: string) {\n    this.secret = secret;\n  }\n  \n  // Gerar novo service token\n  generateToken(serviceName: string, permissions: string[]): string {\n    const tokenId = crypto.randomUUID();\n    \n    const token = jwt.sign(\n      {\n        type: 'service',\n        service: serviceName,\n        permissions,\n        tokenId\n      },\n      this.secret,\n      { expiresIn: '90d' } // Tokens de serviço duram mais\n    );\n    \n    // Armazenar metadados\n    this.tokens.set(tokenId, {\n      serviceName,\n      permissions,\n      createdAt: new Date(),\n      lastUsed: null\n    });\n    \n    return token;\n  }\n  \n  // Validar token\n  validateToken(token: string): ServiceTokenPayload | null {\n    try {\n      const payload = jwt.verify(token, this.secret) as ServiceTokenPayload;\n      \n      if (payload.type !== 'service') {\n        return null;\n      }\n      \n      // Atualizar último uso\n      const tokenData = this.tokens.get(payload.tokenId);\n      if (tokenData) {\n        tokenData.lastUsed = new Date();\n      }\n      \n      return payload;\n    } catch (error) {\n      return null;\n    }\n  }\n  \n  // Revogar token\n  revokeToken(tokenId: string) {\n    this.tokens.delete(tokenId);\n  }\n  \n  // Verificar permissão\n  hasPermission(token: string, permission: string): boolean {\n    const payload = this.validateToken(token);\n    if (!payload) return false;\n    \n    return payload.permissions.includes(permission) || \n           payload.permissions.includes('*');\n  }\n}\n\ninterface ServiceToken {\n  serviceName: string;\n  permissions: string[];\n  createdAt: Date;\n  lastUsed: Date | null;\n}\n\ninterface ServiceTokenPayload {\n  type: 'service';\n  service: string;\n  permissions: string[];\n  tokenId: string;\n}\n```\n\n### Middleware de Autenticação\n\n```typescript\n// src/middleware/auth.ts\nimport { MCPRequest, MCPResponse } from '@modelcontextprotocol/sdk';\n\nclass AuthMiddleware {\n  constructor(private tokenManager: ServiceTokenManager) {}\n  \n  async authenticate(request: MCPRequest): Promise<MCPResponse | null> {\n    const token = this.extractToken(request);\n    \n    if (!token) {\n      return {\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: 'Authentication token required'\n        }\n      };\n    }\n    \n    const payload = this.tokenManager.validateToken(token);\n    \n    if (!payload) {\n      return {\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: 'Invalid or expired token'\n        }\n      };\n    }\n    \n    // Adicionar informações de autenticação ao request\n    request.metadata = {\n      ...request.metadata,\n      authenticatedService: payload.service,\n      permissions: payload.permissions\n    };\n    \n    return null; // Autenticação OK\n  }\n  \n  private extractToken(request: MCPRequest): string | null {\n    // Extrair de header Authorization\n    const authHeader = request.metadata?.headers?.['authorization'];\n    if (authHeader?.startsWith('Bearer ')) {\n      return authHeader.substring(7);\n    }\n    \n    // Ou de metadata\n    return request.metadata?.authToken || null;\n  }\n}\n```\n\n### Controle de Acesso Baseado em Permissões\n\n```typescript\n// src/auth/permissions.ts\nclass PermissionManager {\n  private permissions: Map<string, string[]> = new Map();\n  \n  // Definir permissões necessárias para cada método\n  setMethodPermissions(server: string, method: string, permissions: string[]) {\n    const key = `${server}:${method}`;\n    this.permissions.set(key, permissions);\n  }\n  \n  // Verificar se token tem permissões necessárias\n  checkPermission(\n    tokenPermissions: string[],\n    server: string,\n    method: string\n  ): boolean {\n    const key = `${server}:${method}`;\n    const required = this.permissions.get(key) || [];\n    \n    // Se não há permissões requeridas, permitir\n    if (required.length === 0) return true;\n    \n    // Verificar se token tem todas as permissões necessárias\n    return required.every(perm => \n      tokenPermissions.includes(perm) || tokenPermissions.includes('*')\n    );\n  }\n}\n\n// Uso\nconst permManager = new PermissionManager();\npermManager.setMethodPermissions('billing', 'create_invoice', ['billing:write']);\npermManager.setMethodPermissions('billing', 'get_invoice', ['billing:read']);\npermManager.setMethodPermissions('database', 'query', ['database:read']);\npermManager.setMethodPermissions('database', 'write', ['database:write']);\n```\n\n## Rate Limiting\n\n### Implementação de Rate Limiting\n\n```typescript\n// src/middleware/rate-limit.ts\nimport { MCPRequest, MCPResponse } from '@modelcontextprotocol/sdk';\n\ninterface RateLimitConfig {\n  windowMs: number;      // Janela de tempo em ms\n  maxRequests: number;   // Máximo de requisições\n  skipSuccessful?: boolean; // Não contar requisições bem-sucedidas\n  skipFailed?: boolean;     // Não contar requisições falhadas\n}\n\nclass RateLimiter {\n  private requests: Map<string, RequestRecord[]> = new Map();\n  \n  constructor(private config: RateLimitConfig) {}\n  \n  async checkLimit(request: MCPRequest): Promise<MCPResponse | null> {\n    const key = this.getKey(request);\n    const now = Date.now();\n    \n    // Obter histórico de requisições\n    let records = this.requests.get(key) || [];\n    \n    // Remover requisições antigas (fora da janela)\n    records = records.filter(\n      r => now - r.timestamp < this.config.windowMs\n    );\n    \n    // Verificar limite\n    if (records.length >= this.config.maxRequests) {\n      const oldest = records[0].timestamp;\n      const resetTime = oldest + this.config.windowMs;\n      \n      return {\n        success: false,\n        error: {\n          code: 'RATE_LIMIT_EXCEEDED',\n          message: `Rate limit exceeded. Try again after ${new Date(resetTime).toISOString()}`,\n          details: {\n            limit: this.config.maxRequests,\n            window: this.config.windowMs,\n            resetTime\n          }\n        }\n      };\n    }\n    \n    // Registrar requisição\n    records.push({ timestamp: now, success: null });\n    this.requests.set(key, records);\n    \n    return null; // Limite OK\n  }\n  \n  recordResult(request: MCPRequest, success: boolean) {\n    const key = this.getKey(request);\n    const records = this.requests.get(key) || [];\n    \n    if (records.length > 0) {\n      records[records.length - 1].success = success;\n    }\n  }\n  \n  private getKey(request: MCPRequest): string {\n    // Usar service token ou IP como chave\n    const service = request.metadata?.authenticatedService;\n    const ip = request.metadata?.clientIp;\n    \n    return service || ip || 'anonymous';\n  }\n}\n\ninterface RequestRecord {\n  timestamp: number;\n  success: boolean | null;\n}\n\n// Uso\nconst rateLimiter = new RateLimiter({\n  windowMs: 60 * 1000,  // 1 minuto\n  maxRequests: 100,      // 100 requisições por minuto\n  skipSuccessful: false\n});\n```\n\n### Rate Limiting por Método\n\n```typescript\n// Rate limiting diferente por método\nclass MethodBasedRateLimiter {\n  private limiters: Map<string, RateLimiter> = new Map();\n  \n  setLimit(server: string, method: string, config: RateLimitConfig) {\n    const key = `${server}:${method}`;\n    this.limiters.set(key, new RateLimiter(config));\n  }\n  \n  async checkLimit(request: MCPRequest): Promise<MCPResponse | null> {\n    const key = `${request.server}:${request.method}`;\n    const limiter = this.limiters.get(key);\n    \n    if (!limiter) {\n      // Sem limite específico, usar padrão\n      return null;\n    }\n    \n    return await limiter.checkLimit(request);\n  }\n}\n\n// Configurar limites diferentes\nconst methodLimiter = new MethodBasedRateLimiter();\n\n// Métodos de leitura: mais permissivos\nmethodLimiter.setLimit('database', 'query', {\n  windowMs: 60 * 1000,\n  maxRequests: 1000\n});\n\n// Métodos de escrita: mais restritivos\nmethodLimiter.setLimit('database', 'write', {\n  windowMs: 60 * 1000,\n  maxRequests: 100\n});\n\n// Métodos críticos: muito restritivos\nmethodLimiter.setLimit('billing', 'create_invoice', {\n  windowMs: 60 * 1000,\n  maxRequests: 10\n});\n```\n\n## Web Application Firewall (WAF)\n\n### Implementação Básica de WAF\n\n```typescript\n// src/security/waf.ts\nimport { MCPRequest, MCPResponse } from '@modelcontextprotocol/sdk';\n\nclass WAF {\n  private rules: WAFRule[] = [];\n  \n  addRule(rule: WAFRule) {\n    this.rules.push(rule);\n  }\n  \n  async check(request: MCPRequest): Promise<MCPResponse | null> {\n    for (const rule of this.rules) {\n      const result = await rule.check(request);\n      if (!result.allowed) {\n        return {\n          success: false,\n          error: {\n            code: 'WAF_BLOCKED',\n            message: result.reason || 'Request blocked by WAF',\n            details: {\n              rule: rule.name,\n              reason: result.reason\n            }\n          }\n        };\n      }\n    }\n    \n    return null; // Request permitido\n  }\n}\n\ninterface WAFRule {\n  name: string;\n  check(request: MCPRequest): Promise<{ allowed: boolean; reason?: string }>;\n}\n\n// Regra: Bloquear SQL injection\nclass SQLInjectionRule implements WAFRule {\n  name = 'SQL Injection Protection';\n  \n  private sqlKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'SELECT', 'UNION'];\n  \n  async check(request: MCPRequest): Promise<{ allowed: boolean; reason?: string }> {\n    const paramsStr = JSON.stringify(request.params).toUpperCase();\n    \n    for (const keyword of this.sqlKeywords) {\n      if (paramsStr.includes(keyword)) {\n        return {\n          allowed: false,\n          reason: `Potential SQL injection detected: ${keyword}`\n        };\n      }\n    }\n    \n    return { allowed: true };\n  }\n}\n\n// Regra: Validar tamanho de payload\nclass PayloadSizeRule implements WAFRule {\n  name = 'Payload Size Limit';\n  \n  constructor(private maxSize: number) {}\n  \n  async check(request: MCPRequest): Promise<{ allowed: boolean; reason?: string }> {\n    const size = JSON.stringify(request).length;\n    \n    if (size > this.maxSize) {\n      return {\n        allowed: false,\n        reason: `Payload too large: ${size} bytes (max: ${this.maxSize})`\n      };\n    }\n    \n    return { allowed: true };\n  }\n}\n\n// Regra: Validar formato de parâmetros\nclass ParameterValidationRule implements WAFRule {\n  name = 'Parameter Validation';\n  \n  async check(request: MCPRequest): Promise<{ allowed: boolean; reason?: string }> {\n    // Validar que params é um objeto\n    if (request.params && typeof request.params !== 'object') {\n      return {\n        allowed: false,\n        reason: 'Parameters must be an object'\n      };\n    }\n    \n    // Validar profundidade máxima\n    const depth = this.getDepth(request.params);\n    if (depth > 10) {\n      return {\n        allowed: false,\n        reason: 'Parameters too deeply nested'\n      };\n    }\n    \n    return { allowed: true };\n  }\n  \n  private getDepth(obj: any, current = 0): number {\n    if (typeof obj !== 'object' || obj === null) return current;\n    \n    let max = current;\n    for (const value of Object.values(obj)) {\n      max = Math.max(max, this.getDepth(value, current + 1));\n    }\n    \n    return max;\n  }\n}\n\n// Configurar WAF\nconst waf = new WAF();\nwaf.addRule(new SQLInjectionRule());\nwaf.addRule(new PayloadSizeRule(1024 * 1024)); // 1MB\nwaf.addRule(new ParameterValidationRule());\n```\n\n## Monitoramento e Auditoria\n\n### Logging de Segurança\n\n```typescript\n// src/security/audit.ts\nclass SecurityAuditor {\n  private logs: AuditLog[] = [];\n  \n  log(event: AuditEvent) {\n    const log: AuditLog = {\n      timestamp: new Date().toISOString(),\n      event: event.type,\n      service: event.service,\n      method: event.method,\n      success: event.success,\n      error: event.error,\n      metadata: event.metadata\n    };\n    \n    this.logs.push(log);\n    \n    // Enviar para sistema de logging externo\n    this.sendToExternalLogger(log);\n  }\n  \n  private sendToExternalLogger(log: AuditLog) {\n    // Integração com sistema de logging (ex: Datadog, Splunk)\n    // ...\n  }\n  \n  // Consultar logs\n  query(filters: AuditFilters): AuditLog[] {\n    return this.logs.filter(log => {\n      if (filters.service && log.service !== filters.service) return false;\n      if (filters.method && log.method !== filters.method) return false;\n      if (filters.success !== undefined && log.success !== filters.success) return false;\n      if (filters.startDate && log.timestamp < filters.startDate) return false;\n      if (filters.endDate && log.timestamp > filters.endDate) return false;\n      return true;\n    });\n  }\n}\n\ninterface AuditEvent {\n  type: 'auth_success' | 'auth_failure' | 'request' | 'rate_limit' | 'waf_block';\n  service: string;\n  method: string;\n  success: boolean;\n  error?: string;\n  metadata?: Record<string, any>;\n}\n\ninterface AuditLog extends AuditEvent {\n  timestamp: string;\n}\n\ninterface AuditFilters {\n  service?: string;\n  method?: string;\n  success?: boolean;\n  startDate?: string;\n  endDate?: string;\n}\n```\n\n## Implementação Completa\n\n```typescript\n// src/security/security-middleware.ts\nclass SecurityMiddleware {\n  constructor(\n    private auth: AuthMiddleware,\n    private rateLimiter: RateLimiter,\n    private waf: WAF,\n    private auditor: SecurityAuditor\n  ) {}\n  \n  async process(request: MCPRequest): Promise<MCPResponse | null> {\n    // 1. WAF\n    const wafResult = await this.waf.check(request);\n    if (wafResult) {\n      this.auditor.log({\n        type: 'waf_block',\n        service: request.server,\n        method: request.method,\n        success: false,\n        error: wafResult.error?.message\n      });\n      return wafResult;\n    }\n    \n    // 2. Autenticação\n    const authResult = await this.auth.authenticate(request);\n    if (authResult) {\n      this.auditor.log({\n        type: 'auth_failure',\n        service: request.server,\n        method: request.method,\n        success: false,\n        error: authResult.error?.message\n      });\n      return authResult;\n    }\n    \n    this.auditor.log({\n      type: 'auth_success',\n      service: request.server,\n      method: request.method,\n      success: true\n    });\n    \n    // 3. Rate Limiting\n    const rateLimitResult = await this.rateLimiter.checkLimit(request);\n    if (rateLimitResult) {\n      this.auditor.log({\n        type: 'rate_limit',\n        service: request.server,\n        method: request.method,\n        success: false,\n        error: rateLimitResult.error?.message\n      });\n      return rateLimitResult;\n    }\n    \n    // 4. Permissões\n    const hasPermission = this.checkPermissions(request);\n    if (!hasPermission) {\n      this.auditor.log({\n        type: 'auth_failure',\n        service: request.server,\n        method: request.method,\n        success: false,\n        error: 'Insufficient permissions'\n      });\n      \n      return {\n        success: false,\n        error: {\n          code: 'FORBIDDEN',\n          message: 'Insufficient permissions'\n        }\n      };\n    }\n    \n    // Tudo OK\n    return null;\n  }\n  \n  private checkPermissions(request: MCPRequest): boolean {\n    const permissions = request.metadata?.permissions || [];\n    const required = this.getRequiredPermissions(request.server, request.method);\n    \n    return required.every(perm => \n      permissions.includes(perm) || permissions.includes('*')\n    );\n  }\n  \n  private getRequiredPermissions(server: string, method: string): string[] {\n    // Lógica para determinar permissões necessárias\n    // ...\n    return [];\n  }\n}\n```\n\n## Conclusão\n\nSegurança e governança em MCPs envolvem:\n\n- **Autenticação**: Service tokens para identificar serviços\n- **Autorização**: Controle de acesso baseado em permissões\n- **Rate Limiting**: Prevenir abuso e controlar custos\n- **WAF**: Proteção contra ataques comuns\n- **Auditoria**: Logging e monitoramento de segurança\n\nImplementar essas camadas de segurança é essencial antes de expor MCPs em produção. No próximo tópico, vamos explorar como transformar sua empresa em um \"MCP\", aplicando essas práticas de segurança.",
  "resources": [
    {
      "type": "link",
      "title": "OWASP Top 10",
      "url": "https://owasp.org/www-project-top-ten/",
      "description": "Principais vulnerabilidades de segurança web"
    },
    {
      "type": "link",
      "title": "JWT Best Practices",
      "url": "https://jwt.io/introduction",
      "description": "Boas práticas para uso de JWT"
    },
    {
      "type": "code",
      "title": "Rate Limiting Strategies",
      "description": "Estratégias e padrões de rate limiting"
    },
    {
      "type": "link",
      "title": "WAF Implementation Guide",
      "description": "Guia de implementação de WAF"
    }
  ]
}

