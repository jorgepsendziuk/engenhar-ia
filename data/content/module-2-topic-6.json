{
  "id": "module-2-topic-6",
  "title": "Mão na massa: integrando IA ao back-end",
  "content": "## Introdução\n\nNeste tópico, vamos colocar a mão na massa e construir um projeto completo: integrar um LLM da OpenAI a um back-end existente. Vamos criar uma API REST que utiliza IA para processar requisições, implementando autenticação, versionamento, testes e todas as boas práticas que aprendemos até agora.\n\nEste projeto servirá como exemplo prático de como aplicar todas as técnicas e conceitos que exploramos nos tópicos anteriores.\n\n## Visão Geral do Projeto\n\nVamos construir uma **API de Análise de Código com IA** que:\n\n- Recebe código via API\n- Analisa o código usando GPT-4\n- Retorna análise detalhada (qualidade, bugs, sugestões)\n- Inclui autenticação\n- Suporta versionamento\n- Tem testes completos\n- Implementa todas as boas práticas de custo-eficiência\n\n## Estrutura do Projeto\n\n```\ncode-analysis-api/\n├── src/\n│   ├── routes/\n│   │   └── analysis.js\n│   ├── middleware/\n│   │   ├── auth.js\n│   │   └── versioning.js\n│   ├── services/\n│   │   ├── openai.js\n│   │   └── cache.js\n│   ├── utils/\n│   │   └── validators.js\n│   └── app.js\n├── tests/\n│   ├── analysis.test.js\n│   └── integration.test.js\n├── package.json\n└── README.md\n```\n\n## Setup Inicial\n\n### 1. Inicializar Projeto\n\n```bash\nmkdir code-analysis-api\ncd code-analysis-api\nnpm init -y\n```\n\n### 2. Instalar Dependências\n\n```bash\nnpm install express openai dotenv jsonwebtoken node-cache\nnpm install --save-dev jest supertest\n```\n\n### 3. Estrutura de Arquivos\n\n```javascript\n// package.json\n{\n  \"name\": \"code-analysis-api\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"node src/app.js\",\n    \"dev\": \"nodemon src/app.js\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"openai\": \"^4.20.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"node-cache\": \"^5.1.2\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.7.0\",\n    \"supertest\": \"^6.3.3\",\n    \"nodemon\": \"^3.0.1\"\n  }\n}\n```\n\n## Implementação Passo a Passo\n\n### 1. Configuração e Variáveis de Ambiente\n\n```javascript\n// .env\nOPENAI_API_KEY=sk-...\nJWT_SECRET=seu-secret-super-seguro\nPORT=3000\nNODE_ENV=development\nCACHE_TTL=3600\n```\n\n```javascript\n// src/config.js\nrequire('dotenv').config();\n\nmodule.exports = {\n  openai: {\n    apiKey: process.env.OPENAI_API_KEY\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET\n  },\n  server: {\n    port: process.env.PORT || 3000\n  },\n  cache: {\n    ttl: parseInt(process.env.CACHE_TTL) || 3600\n  }\n};\n```\n\n### 2. Serviço OpenAI\n\n```javascript\n// src/services/openai.js\nconst { OpenAI } = require('openai');\nconst config = require('../config');\n\nclass OpenAIService {\n  constructor() {\n    this.client = new OpenAI({ apiKey: config.openai.apiKey });\n  }\n  \n  async analyzeCode(code, language, options = {}) {\n    const prompt = this.buildAnalysisPrompt(code, language, options);\n    \n    try {\n      const response = await this.client.chat.completions.create({\n        model: options.model || 'gpt-4-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'Você é um analista de código sênior. Forneça análises detalhadas e construtivas.'\n          },\n          {\n            role: 'user',\n            content: prompt\n          }\n        ],\n        temperature: options.temperature || 0.3,\n        max_tokens: options.maxTokens || 1000\n      });\n      \n      return {\n        analysis: response.choices[0].message.content,\n        usage: response.usage,\n        model: response.model\n      };\n    } catch (error) {\n      throw new Error(`OpenAI API error: ${error.message}`);\n    }\n  }\n  \n  buildAnalysisPrompt(code, language, options) {\n    const focusAreas = options.focusAreas || ['quality', 'bugs', 'suggestions'];\n    \n    return `Analise o seguinte código ${language}:\n\n\\`\\`\\`${language}\n${code}\n\\`\\`\\`\n\nForneça uma análise focada em:\n${focusAreas.map(area => `- ${this.getFocusDescription(area)}`).join('\\n')}\n\nFormato da resposta: JSON com a seguinte estrutura:\n{\n  \"quality\": { \"score\": 0-10, \"comments\": \"...\" },\n  \"bugs\": [ { \"line\": number, \"severity\": \"high|medium|low\", \"description\": \"...\" } ],\n  \"suggestions\": [ { \"type\": \"...\", \"description\": \"...\" } ],\n  \"summary\": \"...\"\n}`;\n  }\n  \n  getFocusDescription(area) {\n    const descriptions = {\n      quality: 'Qualidade do código (legibilidade, estrutura, padrões)',\n      bugs: 'Possíveis bugs e problemas',\n      suggestions: 'Sugestões de melhoria',\n      performance: 'Otimizações de performance',\n      security: 'Problemas de segurança'\n    };\n    return descriptions[area] || area;\n  }\n}\n\nmodule.exports = new OpenAIService();\n```\n\n### 3. Serviço de Cache\n\n```javascript\n// src/services/cache.js\nconst NodeCache = require('node-cache');\nconst crypto = require('crypto');\nconst config = require('../config');\n\nclass CacheService {\n  constructor() {\n    this.cache = new NodeCache({ stdTTL: config.cache.ttl });\n  }\n  \n  generateKey(code, language, options) {\n    const content = JSON.stringify({ code, language, options });\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n  \n  get(code, language, options) {\n    const key = this.generateKey(code, language, options);\n    return this.cache.get(key);\n  }\n  \n  set(code, language, options, value) {\n    const key = this.generateKey(code, language, options);\n    this.cache.set(key, value);\n  }\n  \n  clear() {\n    this.cache.flushAll();\n  }\n}\n\nmodule.exports = new CacheService();\n```\n\n### 4. Middleware de Autenticação\n\n```javascript\n// src/middleware/auth.js\nconst jwt = require('jsonwebtoken');\nconst config = require('../config');\n\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Token de acesso requerido' });\n  }\n  \n  jwt.verify(token, config.jwt.secret, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Token inválido ou expirado' });\n    }\n    \n    req.user = user;\n    next();\n  });\n}\n\nfunction generateToken(userId) {\n  return jwt.sign(\n    { userId },\n    config.jwt.secret,\n    { expiresIn: '24h' }\n  );\n}\n\nmodule.exports = { authenticateToken, generateToken };\n```\n\n### 5. Middleware de Versionamento\n\n```javascript\n// src/middleware/versioning.js\nfunction apiVersioning(req, res, next) {\n  const apiVersion = req.headers['api-version'] || 'v1';\n  \n  // Validar versão suportada\n  const supportedVersions = ['v1', 'v2'];\n  if (!supportedVersions.includes(apiVersion)) {\n    return res.status(400).json({\n      error: 'Versão de API não suportada',\n      supportedVersions\n    });\n  }\n  \n  req.apiVersion = apiVersion;\n  next();\n}\n\nmodule.exports = apiVersioning;\n```\n\n### 6. Validadores\n\n```javascript\n// src/utils/validators.js\nfunction validateCodeAnalysisRequest(req, res, next) {\n  const { code, language } = req.body;\n  \n  if (!code || typeof code !== 'string') {\n    return res.status(400).json({ error: 'Código é obrigatório e deve ser uma string' });\n  }\n  \n  if (code.length > 10000) {\n    return res.status(400).json({ error: 'Código muito longo (máximo 10000 caracteres)' });\n  }\n  \n  if (!language || typeof language !== 'string') {\n    return res.status(400).json({ error: 'Linguagem é obrigatória' });\n  }\n  \n  const supportedLanguages = ['javascript', 'python', 'java', 'typescript', 'go', 'rust'];\n  if (!supportedLanguages.includes(language.toLowerCase())) {\n    return res.status(400).json({\n      error: 'Linguagem não suportada',\n      supportedLanguages\n    });\n  }\n  \n  next();\n}\n\nmodule.exports = { validateCodeAnalysisRequest };\n```\n\n### 7. Rota de Análise\n\n```javascript\n// src/routes/analysis.js\nconst express = require('express');\nconst router = express.Router();\nconst openaiService = require('../services/openai');\nconst cacheService = require('../services/cache');\nconst { validateCodeAnalysisRequest } = require('../utils/validators');\n\nrouter.post('/analyze', validateCodeAnalysisRequest, async (req, res) => {\n  try {\n    const { code, language, options = {} } = req.body;\n    \n    // Verificar cache\n    const cached = cacheService.get(code, language, options);\n    if (cached) {\n      return res.json({\n        ...cached,\n        cached: true\n      });\n    }\n    \n    // Analisar código\n    const result = await openaiService.analyzeCode(code, language, options);\n    \n    // Parse da resposta JSON\n    let analysis;\n    try {\n      analysis = JSON.parse(result.analysis);\n    } catch (e) {\n      // Se não for JSON válido, retornar como texto\n      analysis = { raw: result.analysis };\n    }\n    \n    const response = {\n      analysis,\n      usage: result.usage,\n      model: result.model,\n      cached: false\n    };\n    \n    // Cachear resultado\n    cacheService.set(code, language, options, response);\n    \n    res.json(response);\n  } catch (error) {\n    console.error('Error analyzing code:', error);\n    res.status(500).json({\n      error: 'Erro ao analisar código',\n      message: error.message\n    });\n  }\n});\n\n// Rota de health check\nrouter.get('/health', (req, res) => {\n  res.json({ status: 'ok', timestamp: new Date().toISOString() });\n});\n\nmodule.exports = router;\n```\n\n### 8. Aplicação Principal\n\n```javascript\n// src/app.js\nconst express = require('express');\nconst config = require('./config');\nconst analysisRoutes = require('./routes/analysis');\nconst { authenticateToken } = require('./middleware/auth');\nconst apiVersioning = require('./middleware/versioning');\n\nconst app = express();\n\n// Middleware global\napp.use(express.json({ limit: '10mb' }));\napp.use(apiVersioning);\n\n// Rotas públicas\napp.get('/', (req, res) => {\n  res.json({\n    name: 'Code Analysis API',\n    version: req.apiVersion,\n    endpoints: {\n      'POST /api/analyze': 'Analisar código',\n      'GET /api/health': 'Health check'\n    }\n  });\n});\n\napp.get('/api/health', (req, res) => {\n  res.json({ status: 'ok' });\n});\n\n// Rotas protegidas\napp.use('/api', authenticateToken, analysisRoutes);\n\n// Middleware de erro\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    error: 'Erro interno do servidor',\n    message: config.server.nodeEnv === 'development' ? err.message : undefined\n  });\n});\n\n// Iniciar servidor\nconst PORT = config.server.port;\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`API Version: v1, v2`);\n});\n\nmodule.exports = app;\n```\n\n## Testes\n\n### 1. Testes Unitários\n\n```javascript\n// tests/analysis.test.js\nconst openaiService = require('../src/services/openai');\nconst cacheService = require('../src/services/cache');\n\njest.mock('openai');\n\ndescribe('Code Analysis Service', () => {\n  beforeEach(() => {\n    cacheService.clear();\n  });\n  \n  test('should analyze code successfully', async () => {\n    const code = 'function test() { return true; }';\n    const language = 'javascript';\n    \n    // Mock OpenAI response\n    const mockResponse = {\n      choices: [{\n        message: {\n          content: JSON.stringify({\n            quality: { score: 8, comments: 'Good code' },\n            bugs: [],\n            suggestions: [],\n            summary: 'Clean code'\n          })\n        }\n      }],\n      usage: { prompt_tokens: 100, completion_tokens: 50 },\n      model: 'gpt-4-turbo'\n    };\n    \n    // Test implementation\n    // ...\n  });\n  \n  test('should use cache for identical requests', async () => {\n    // Test cache functionality\n    // ...\n  });\n});\n```\n\n### 2. Testes de Integração\n\n```javascript\n// tests/integration.test.js\nconst request = require('supertest');\nconst app = require('../src/app');\nconst { generateToken } = require('../src/middleware/auth');\n\ndescribe('API Integration Tests', () => {\n  let token;\n  \n  beforeAll(() => {\n    token = generateToken('test-user');\n  });\n  \n  test('POST /api/analyze - should analyze code', async () => {\n    const response = await request(app)\n      .post('/api/analyze')\n      .set('Authorization', `Bearer ${token}`)\n      .set('api-version', 'v1')\n      .send({\n        code: 'function test() { return true; }',\n        language: 'javascript'\n      });\n    \n    expect(response.status).toBe(200);\n    expect(response.body).toHaveProperty('analysis');\n    expect(response.body).toHaveProperty('usage');\n  });\n  \n  test('POST /api/analyze - should return 401 without token', async () => {\n    const response = await request(app)\n      .post('/api/analyze')\n      .send({\n        code: 'function test() { return true; }',\n        language: 'javascript'\n      });\n    \n    expect(response.status).toBe(401);\n  });\n  \n  test('POST /api/analyze - should validate input', async () => {\n    const response = await request(app)\n      .post('/api/analyze')\n      .set('Authorization', `Bearer ${token}`)\n      .send({\n        code: '',\n        language: 'javascript'\n      });\n    \n    expect(response.status).toBe(400);\n  });\n});\n```\n\n## Documentação da API\n\n### Endpoints\n\n#### POST /api/analyze\n\nAnalisa código usando IA.\n\n**Headers**:\n- `Authorization: Bearer <token>` (obrigatório)\n- `api-version: v1` (opcional, default: v1)\n\n**Body**:\n```json\n{\n  \"code\": \"function test() { return true; }\",\n  \"language\": \"javascript\",\n  \"options\": {\n    \"model\": \"gpt-4-turbo\",\n    \"focusAreas\": [\"quality\", \"bugs\", \"suggestions\"],\n    \"temperature\": 0.3,\n    \"maxTokens\": 1000\n  }\n}\n```\n\n**Response**:\n```json\n{\n  \"analysis\": {\n    \"quality\": { \"score\": 8, \"comments\": \"...\" },\n    \"bugs\": [...],\n    \"suggestions\": [...],\n    \"summary\": \"...\"\n  },\n  \"usage\": {\n    \"prompt_tokens\": 100,\n    \"completion_tokens\": 50,\n    \"total_tokens\": 150\n  },\n  \"model\": \"gpt-4-turbo\",\n  \"cached\": false\n}\n```\n\n## Autenticação\n\n### Gerar Token\n\n```javascript\n// scripts/generate-token.js\nconst { generateToken } = require('../src/middleware/auth');\n\nconst userId = process.argv[2] || 'default-user';\nconst token = generateToken(userId);\n\nconsole.log('Token:', token);\n```\n\n```bash\nnode scripts/generate-token.js my-user-id\n```\n\n## Uso da API\n\n### Exemplo com cURL\n\n```bash\n# Gerar token primeiro\nTOKEN=$(node scripts/generate-token.js my-user)\n\n# Analisar código\ncurl -X POST http://localhost:3000/api/analyze \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"api-version: v1\" \\\n  -d '{\n    \"code\": \"function add(a, b) { return a + b; }\",\n    \"language\": \"javascript\",\n    \"options\": {\n      \"focusAreas\": [\"quality\", \"bugs\"]\n    }\n  }'\n```\n\n### Exemplo com JavaScript\n\n```javascript\nconst axios = require('axios');\n\nasync function analyzeCode(code, language, token) {\n  try {\n    const response = await axios.post(\n      'http://localhost:3000/api/analyze',\n      { code, language },\n      {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'api-version': 'v1'\n        }\n      }\n    );\n    \n    return response.data;\n  } catch (error) {\n    console.error('Error:', error.response?.data || error.message);\n    throw error;\n  }\n}\n\n// Uso\nconst token = 'seu-token-aqui';\nconst result = await analyzeCode(\n  'function test() { return true; }',\n  'javascript',\n  token\n);\n\nconsole.log(result.analysis);\n```\n\n## Deploy e Produção\n\n### Variáveis de Ambiente de Produção\n\n```bash\n# .env.production\nNODE_ENV=production\nPORT=3000\nOPENAI_API_KEY=sk-...\nJWT_SECRET=secret-super-seguro-aleatorio\nCACHE_TTL=3600\n```\n\n### Dockerfile\n\n```dockerfile\nFROM node:18-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [\"node\", \"src/app.js\"]\n```\n\n## Conclusão\n\nConstruímos uma API completa que:\n\n- ✅ Integra LLM (OpenAI) ao back-end\n- ✅ Implementa autenticação JWT\n- ✅ Suporta versionamento de API\n- ✅ Inclui cache para otimização\n- ✅ Tem validação de entrada\n- ✅ Possui testes unitários e de integração\n- ✅ Segue boas práticas de estrutura\n- ✅ Está pronta para produção\n\nEste projeto demonstra como aplicar todas as técnicas aprendidas: otimização de custos (cache), tratamento de erros, validação, autenticação e muito mais. No próximo tópico, vamos criar projetos ainda mais avançados combinando múltiplas modalidades!",
  "resources": [
    {
      "type": "code",
      "title": "Repositório Completo do Projeto",
      "description": "Código completo do projeto no GitHub"
    },
    {
      "type": "link",
      "title": "Express.js Documentation",
      "url": "https://expressjs.com",
      "description": "Documentação do Express.js"
    },
    {
      "type": "link",
      "title": "JWT Best Practices",
      "url": "https://jwt.io",
      "description": "Guia de boas práticas para JWT"
    },
    {
      "type": "link",
      "title": "Jest Testing Framework",
      "url": "https://jestjs.io",
      "description": "Documentação do Jest para testes"
    }
  ]
}

