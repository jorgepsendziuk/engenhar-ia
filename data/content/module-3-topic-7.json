{
  "id": "module-3-topic-7",
  "title": "Casos de uso reais em empresas",
  "content": "## Introdução\n\nEste tópico explora casos de uso reais de como empresas estão usando MCPs para conectar IA a sistemas legados, criar automações, copilots internos e assistentes corporativos. Esses exemplos práticos demonstram o valor real do MCP em cenários empresariais.\n\n## Conectando IA a Sistemas Legados\n\n### Desafio: Sistemas Legados\n\nMuitas empresas têm sistemas legados que:\n- Não têm APIs modernas\n- Usam formatos de dados antigos\n- Têm documentação limitada\n- São difíceis de integrar\n\n### Solução: MCP como Camada de Adaptação\n\nMCP pode servir como camada de adaptação entre IA e sistemas legados:\n\n```typescript\n// Exemplo: Integração com sistema legado de mainframe\nclass LegacySystemMCPServer extends MCPServer {\n  constructor(private legacyConnector: LegacyConnector) {\n    super('legacy-system', '1.0.0');\n    \n    this.registerMethod('query_legacy', this.queryLegacy.bind(this));\n  }\n  \n  async queryLegacy(request: MCPRequest): Promise<MCPResponse> {\n    const { query, format } = request.params;\n    \n    try {\n      // Conectar ao sistema legado\n      const legacyData = await this.legacyConnector.executeQuery(query);\n      \n      // Transformar formato legado para formato moderno\n      const modernData = this.transformLegacyFormat(legacyData, format);\n      \n      return {\n        success: true,\n        data: modernData\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  private transformLegacyFormat(data: any, format: string) {\n    // Transformar dados do formato legado para formato padronizado\n    // ...\n    return data;\n  }\n}\n```\n\n### Caso de Uso: Banco de Dados Legado\n\n**Situação**: Banco de dados antigo sem API REST\n\n**Solução**: MCP Server que expõe queries como métodos MCP\n\n```typescript\nclass LegacyDatabaseMCPServer extends MCPServer {\n  async getCustomerData(request: MCPRequest): Promise<MCPResponse> {\n    // Query direta ao banco legado\n    const result = await this.legacyDB.query(\n      'SELECT * FROM CUSTOMERS WHERE ID = ?',\n      [request.params.customerId]\n    );\n    \n    // Transformar para formato moderno\n    return {\n      success: true,\n      data: this.transformToModernFormat(result)\n    };\n  }\n}\n```\n\n## Automações Internas\n\n### Caso de Uso: Automação de Relatórios\n\n**Situação**: Empresa precisa gerar relatórios complexos combinando dados de múltiplos sistemas\n\n**Solução**: MCP orquestra múltiplos serviços para gerar relatórios\n\n```typescript\nclass ReportAutomationMCP {\n  async generateMonthlyReport(request: MCPRequest): Promise<MCPResponse> {\n    const { month, year } = request.params;\n    \n    // Orquestrar múltiplos serviços\n    const [sales, expenses, customers] = await Promise.all([\n      this.mcpClient.call('crm', 'get_sales', { month, year }),\n      this.mcpClient.call('billing', 'get_expenses', { month, year }),\n      this.mcpClient.call('crm', 'get_new_customers', { month, year })\n    ]);\n    \n    // Combinar dados\n    const report = {\n      period: { month, year },\n      sales: sales.data,\n      expenses: expenses.data,\n      customers: customers.data,\n      summary: this.calculateSummary(sales.data, expenses.data)\n    };\n    \n    return { success: true, data: report };\n  }\n}\n```\n\n### Caso de Uso: Automação de Workflows\n\n**Situação**: Processo manual que envolve múltiplos sistemas\n\n**Solução**: MCP automatiza o workflow completo\n\n```typescript\nclass WorkflowAutomationMCP {\n  async processNewOrder(request: MCPRequest): Promise<MCPResponse> {\n    const { orderData } = request.params;\n    \n    // 1. Criar pedido no sistema de pedidos\n    const order = await this.mcpClient.call('orders', 'create_order', orderData);\n    \n    // 2. Verificar estoque\n    const inventory = await this.mcpClient.call('inventory', 'check_stock', {\n      productId: orderData.productId\n    });\n    \n    // 3. Se tiver estoque, processar pagamento\n    if (inventory.data.inStock) {\n      const payment = await this.mcpClient.call('billing', 'process_payment', {\n        orderId: order.data.id,\n        amount: order.data.total\n      });\n      \n      // 4. Atualizar estoque\n      await this.mcpClient.call('inventory', 'update_stock', {\n        productId: orderData.productId,\n        quantity: -orderData.quantity\n      });\n      \n      // 5. Enviar confirmação\n      await this.mcpClient.call('notifications', 'send_email', {\n        to: orderData.customerEmail,\n        subject: 'Pedido confirmado',\n        body: `Seu pedido #${order.data.id} foi confirmado`\n      });\n    }\n    \n    return { success: true, data: { orderId: order.data.id } };\n  }\n}\n```\n\n## Copilots Internos\n\n### Caso de Uso: Copilot de Vendas\n\n**Situação**: Equipe de vendas precisa de assistente para consultar informações rapidamente\n\n**Solução**: Copilot que usa MCPs para acessar sistemas internos\n\n```typescript\nclass SalesCopilot {\n  async answerQuestion(question: string): Promise<string> {\n    // Analisar pergunta e determinar quais MCPs usar\n    const plan = await this.planQuery(question);\n    \n    // Executar queries\n    const results = await this.executePlan(plan);\n    \n    // Gerar resposta usando LLM\n    const answer = await this.llm.generateResponse(question, results);\n    \n    return answer;\n  }\n  \n  private async planQuery(question: string) {\n    // Usar LLM para planejar queries\n    const analysis = await this.llm.analyze(question);\n    \n    const plan = [];\n    \n    if (analysis.needsCustomerData) {\n      plan.push({ server: 'crm', method: 'get_customer', params: {} });\n    }\n    \n    if (analysis.needsProductData) {\n      plan.push({ server: 'products', method: 'get_product', params: {} });\n    }\n    \n    return plan;\n  }\n}\n\n// Uso\nconst copilot = new SalesCopilot();\nconst answer = await copilot.answerQuestion(\n  'Qual o status do pedido do cliente João Silva?'\n);\n// Resposta: \"O pedido #12345 do cliente João Silva está em trânsito, \n//           previsto para entrega em 2 dias.\"\n```\n\n### Caso de Uso: Copilot de Suporte\n\n**Situação**: Equipe de suporte precisa acessar informações de múltiplos sistemas rapidamente\n\n**Solução**: Copilot integrado com sistemas de suporte, CRM e billing\n\n```typescript\nclass SupportCopilot {\n  async handleSupportRequest(request: string, ticketId?: string) {\n    // Se tem ticket ID, buscar contexto\n    let context = {};\n    if (ticketId) {\n      const ticket = await this.mcpClient.call('support', 'get_ticket', { ticketId });\n      const customer = await this.mcpClient.call('crm', 'get_customer', {\n        customerId: ticket.data.customerId\n      });\n      \n      context = {\n        ticket: ticket.data,\n        customer: customer.data\n      };\n    }\n    \n    // Gerar resposta com contexto\n    const response = await this.llm.generateResponse(request, context);\n    \n    return response;\n  }\n}\n```\n\n## Assistentes Corporativos\n\n### Caso de Uso: Assistente Executivo\n\n**Situação**: Executivos precisam de visão consolidada de múltiplos sistemas\n\n**Solução**: Assistente que agrega dados de todos os sistemas\n\n```typescript\nclass ExecutiveAssistant {\n  async getBusinessOverview(period: string) {\n    // Agregar dados de múltiplos sistemas\n    const [sales, expenses, customers, support] = await Promise.all([\n      this.mcpClient.call('crm', 'get_sales_summary', { period }),\n      this.mcpClient.call('billing', 'get_expenses_summary', { period }),\n      this.mcpClient.call('crm', 'get_customer_metrics', { period }),\n      this.mcpClient.call('support', 'get_ticket_metrics', { period })\n    ]);\n    \n    // Consolidar em visão executiva\n    return {\n      period,\n      sales: sales.data,\n      expenses: expenses.data,\n      customers: customers.data,\n      support: support.data,\n      insights: this.generateInsights(sales.data, expenses.data)\n    };\n  }\n  \n  async answerExecutiveQuestion(question: string) {\n    // Analisar pergunta executiva\n    const overview = await this.getBusinessOverview('current_month');\n    \n    // Gerar resposta com dados consolidados\n    return await this.llm.generateResponse(question, overview);\n  }\n}\n```\n\n### Caso de Uso: Assistente de RH\n\n**Situação**: RH precisa consultar informações de funcionários em múltiplos sistemas\n\n**Solução**: Assistente que integra sistemas de RH, folha de pagamento e benefícios\n\n```typescript\nclass HRAssistant {\n  async getEmployeeInfo(employeeId: string) {\n    const [profile, payroll, benefits] = await Promise.all([\n      this.mcpClient.call('hr', 'get_employee', { employeeId }),\n      this.mcpClient.call('payroll', 'get_payroll_info', { employeeId }),\n      this.mcpClient.call('benefits', 'get_benefits', { employeeId })\n    ]);\n    \n    return {\n      profile: profile.data,\n      payroll: payroll.data,\n      benefits: benefits.data\n    };\n  }\n  \n  async answerHRQuestion(question: string, employeeId?: string) {\n    let context = {};\n    \n    if (employeeId) {\n      context = await this.getEmployeeInfo(employeeId);\n    }\n    \n    return await this.llm.generateResponse(question, context);\n  }\n}\n```\n\n## Estudos de Caso Detalhados\n\n### Estudo de Caso 1: E-commerce\n\n**Desafio**: Integrar IA com sistemas de pedidos, estoque, billing e suporte\n\n**Solução**: Camada MCP unificada\n\n```typescript\nclass EcommerceMCPLayer {\n  // Integra todos os sistemas do e-commerce\n  async handleCustomerQuery(query: string, customerId: string) {\n    // Buscar contexto do cliente\n    const [orders, support, preferences] = await Promise.all([\n      this.mcpClient.call('orders', 'get_customer_orders', { customerId }),\n      this.mcpClient.call('support', 'get_customer_tickets', { customerId }),\n      this.mcpClient.call('crm', 'get_customer_preferences', { customerId })\n    ]);\n    \n    // Gerar resposta personalizada\n    return await this.llm.generateResponse(query, {\n      orders: orders.data,\n      support: support.data,\n      preferences: preferences.data\n    });\n  }\n}\n```\n\n### Estudo de Caso 2: SaaS B2B\n\n**Desafio**: Permitir que clientes consultem dados via IA\n\n**Solução**: MCPs expostos com segurança para clientes\n\n```typescript\nclass CustomerFacingMCP {\n  // MCPs seguros para clientes\n  async handleCustomerRequest(\n    query: string,\n    customerId: string,\n    apiKey: string\n  ) {\n    // Validar acesso do cliente\n    if (!this.validateCustomerAccess(customerId, apiKey)) {\n      throw new Error('Unauthorized');\n    }\n    \n    // Processar query com acesso limitado aos dados do cliente\n    return await this.processQuery(query, customerId);\n  }\n}\n```\n\n## Conclusão\n\nCasos de uso reais de MCPs em empresas incluem:\n\n- **Integração com sistemas legados**: MCP como camada de adaptação\n- **Automações**: Workflows complexos automatizados\n- **Copilots internos**: Assistentes para equipes específicas\n- **Assistentes corporativos**: Visão consolidada de múltiplos sistemas\n\nEsses casos demonstram o valor real do MCP em cenários empresariais, permitindo que empresas aproveitem IA de forma integrada e segura.",
  "resources": [
    {
      "type": "link",
      "title": "Enterprise AI Case Studies",
      "description": "Estudos de caso de IA empresarial"
    },
    {
      "type": "code",
      "title": "MCP Enterprise Examples",
      "description": "Exemplos de implementações MCP empresariais"
    },
    {
      "type": "document",
      "title": "Legacy System Integration Patterns",
      "description": "Padrões de integração com sistemas legados"
    }
  ]
}

