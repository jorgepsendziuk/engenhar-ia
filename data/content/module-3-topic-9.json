{
  "id": "module-3-topic-9",
  "title": "Hands-on: do zero ao MCP em produção",
  "content": "## Introdução\n\nEste tópico final do Módulo 3 é um guia completo hands-on para criar um MCP server do zero, integrá-lo com front-end e back-end, testá-lo em diferentes LLM clients e compô-lo com outros MCPs. Vamos construir um projeto completo e funcional, pronto para produção.\n\n## Projeto: Sistema de Gerenciamento de Tarefas com MCP\n\nVamos criar um sistema completo que:\n- Expõe funcionalidades via MCP Server\n- Integra com front-end React\n- Integra com back-end Node.js\n- Pode ser usado por diferentes LLM clients\n- Compõe com outros MCPs\n\n## Passo 1: Setup do Projeto\n\n### Estrutura Inicial\n\n```bash\nmkdir task-management-mcp\ncd task-management-mcp\nnpm init -y\n\n# Instalar dependências\nnpm install @modelcontextprotocol/sdk express cors dotenv\nnpm install -D typescript @types/node @types/express ts-node nodemon\n```\n\n### Estrutura de Diretórios\n\n```\ntask-management-mcp/\n├── src/\n│   ├── server/\n│   │   ├── mcp-server.ts\n│   │   └── handlers.ts\n│   ├── api/\n│   │   ├── routes.ts\n│   │   └── middleware.ts\n│   ├── services/\n│   │   └── task-service.ts\n│   ├── models/\n│   │   └── task.ts\n│   └── config/\n│       └── index.ts\n├── frontend/\n│   ├── src/\n│   │   ├── components/\n│   │   ├── hooks/\n│   │   └── App.tsx\n│   └── package.json\n├── tests/\n│   ├── mcp-server.test.ts\n│   └── integration.test.ts\n├── package.json\n├── tsconfig.json\n└── README.md\n```\n\n## Passo 2: Criar MCP Server\n\n### Modelo de Dados\n\n```typescript\n// src/models/task.ts\nexport interface Task {\n  id: string;\n  title: string;\n  description: string;\n  status: 'todo' | 'in-progress' | 'done';\n  priority: 'low' | 'medium' | 'high';\n  assignee?: string;\n  dueDate?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n```\n\n### Serviço de Tarefas\n\n```typescript\n// src/services/task-service.ts\nimport { Task } from '../models/task';\n\nclass TaskService {\n  private tasks: Map<string, Task> = new Map();\n  \n  async createTask(data: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task> {\n    const task: Task = {\n      id: crypto.randomUUID(),\n      ...data,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    \n    this.tasks.set(task.id, task);\n    return task;\n  }\n  \n  async getTask(id: string): Promise<Task | null> {\n    return this.tasks.get(id) || null;\n  }\n  \n  async listTasks(filters?: { status?: string; assignee?: string }): Promise<Task[]> {\n    let tasks = Array.from(this.tasks.values());\n    \n    if (filters?.status) {\n      tasks = tasks.filter(t => t.status === filters.status);\n    }\n    \n    if (filters?.assignee) {\n      tasks = tasks.filter(t => t.assignee === filters.assignee);\n    }\n    \n    return tasks;\n  }\n  \n  async updateTask(id: string, updates: Partial<Task>): Promise<Task | null> {\n    const task = this.tasks.get(id);\n    if (!task) return null;\n    \n    const updated = {\n      ...task,\n      ...updates,\n      id, // Não permitir mudar ID\n      updatedAt: new Date().toISOString()\n    };\n    \n    this.tasks.set(id, updated);\n    return updated;\n  }\n  \n  async deleteTask(id: string): Promise<boolean> {\n    return this.tasks.delete(id);\n  }\n}\n\nexport default new TaskService();\n```\n\n### MCP Server\n\n```typescript\n// src/server/mcp-server.ts\nimport { MCPServer, MCPRequest, MCPResponse } from '@modelcontextprotocol/sdk';\nimport taskService from '../services/task-service';\nimport { Task } from '../models/task';\n\nclass TaskManagementMCPServer extends MCPServer {\n  constructor() {\n    super('task-management', '1.0.0');\n    \n    // Registrar métodos\n    this.registerMethod('create_task', this.createTask.bind(this));\n    this.registerMethod('get_task', this.getTask.bind(this));\n    this.registerMethod('list_tasks', this.listTasks.bind(this));\n    this.registerMethod('update_task', this.updateTask.bind(this));\n    this.registerMethod('delete_task', this.deleteTask.bind(this));\n  }\n  \n  async createTask(request: MCPRequest): Promise<MCPResponse> {\n    try {\n      const { title, description, status = 'todo', priority = 'medium', assignee, dueDate } = request.params;\n      \n      if (!title) {\n        return {\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'Title is required' }\n        };\n      }\n      \n      const task = await taskService.createTask({\n        title,\n        description: description || '',\n        status: status as Task['status'],\n        priority: priority as Task['priority'],\n        assignee,\n        dueDate\n      });\n      \n      return {\n        success: true,\n        data: task\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async getTask(request: MCPRequest): Promise<MCPResponse> {\n    try {\n      const { taskId } = request.params;\n      \n      if (!taskId) {\n        return {\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'Task ID is required' }\n        };\n      }\n      \n      const task = await taskService.getTask(taskId);\n      \n      if (!task) {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Task not found' }\n        };\n      }\n      \n      return {\n        success: true,\n        data: task\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async listTasks(request: MCPRequest): Promise<MCPResponse> {\n    try {\n      const { status, assignee } = request.params;\n      \n      const tasks = await taskService.listTasks({ status, assignee });\n      \n      return {\n        success: true,\n        data: { tasks, count: tasks.length }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async updateTask(request: MCPRequest): Promise<MCPResponse> {\n    try {\n      const { taskId, ...updates } = request.params;\n      \n      if (!taskId) {\n        return {\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'Task ID is required' }\n        };\n      }\n      \n      const task = await taskService.updateTask(taskId, updates);\n      \n      if (!task) {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Task not found' }\n        };\n      }\n      \n      return {\n        success: true,\n        data: task\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async deleteTask(request: MCPRequest): Promise<MCPResponse> {\n    try {\n      const { taskId } = request.params;\n      \n      if (!taskId) {\n        return {\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'Task ID is required' }\n        };\n      }\n      \n      const deleted = await taskService.deleteTask(taskId);\n      \n      if (!deleted) {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Task not found' }\n        };\n      }\n      \n      return {\n        success: true,\n        data: { deleted: true }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  private handleError(error: any): MCPResponse {\n    return {\n      success: false,\n      error: {\n        code: 'INTERNAL_ERROR',\n        message: error.message || 'An unexpected error occurred'\n      }\n    };\n  }\n}\n\nexport default TaskManagementMCPServer;\n```\n\n## Passo 3: Integração com Back-end\n\n### API REST que usa MCP Server\n\n```typescript\n// src/api/routes.ts\nimport express from 'express';\nimport { MCPClient } from '@modelcontextprotocol/sdk';\n\nconst router = express.Router();\nconst mcpClient = new MCPClient();\nmcpClient.registerServer('tasks', 'http://localhost:3001');\n\n// Criar tarefa\nrouter.post('/tasks', async (req, res) => {\n  try {\n    const result = await mcpClient.call('tasks', 'create_task', req.body);\n    \n    if (result.success) {\n      res.json(result.data);\n    } else {\n      res.status(400).json(result.error);\n    }\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Listar tarefas\nrouter.get('/tasks', async (req, res) => {\n  try {\n    const result = await mcpClient.call('tasks', 'list_tasks', req.query);\n    \n    if (result.success) {\n      res.json(result.data);\n    } else {\n      res.status(400).json(result.error);\n    }\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Obter tarefa\nrouter.get('/tasks/:id', async (req, res) => {\n  try {\n    const result = await mcpClient.call('tasks', 'get_task', { taskId: req.params.id });\n    \n    if (result.success) {\n      res.json(result.data);\n    } else {\n      res.status(404).json(result.error);\n    }\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Atualizar tarefa\nrouter.put('/tasks/:id', async (req, res) => {\n  try {\n    const result = await mcpClient.call('tasks', 'update_task', {\n      taskId: req.params.id,\n      ...req.body\n    });\n    \n    if (result.success) {\n      res.json(result.data);\n    } else {\n      res.status(400).json(result.error);\n    }\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Deletar tarefa\nrouter.delete('/tasks/:id', async (req, res) => {\n  try {\n    const result = await mcpClient.call('tasks', 'delete_task', { taskId: req.params.id });\n    \n    if (result.success) {\n      res.json(result.data);\n    } else {\n      res.status(404).json(result.error);\n    }\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\nexport default router;\n```\n\n### Servidor Express\n\n```typescript\n// src/api/server.ts\nimport express from 'express';\nimport cors from 'cors';\nimport routes from './routes';\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\napp.use('/api', routes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`API server running on port ${PORT}`);\n});\n```\n\n## Passo 4: Integração com Front-end\n\n### Hook React para MCP\n\n```typescript\n// frontend/src/hooks/useMCP.ts\nimport { useState, useCallback } from 'react';\n\nexport function useMCP(server: string) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  const call = useCallback(async (method: string, params: any) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(`http://localhost:3000/api/mcp/${server}/${method}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(params)\n      });\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        return result.data;\n      } else {\n        throw new Error(result.error?.message || 'Request failed');\n      }\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [server]);\n  \n  return { call, loading, error };\n}\n```\n\n### Componente React\n\n```tsx\n// frontend/src/components/TaskList.tsx\nimport React, { useEffect, useState } from 'react';\nimport { useMCP } from '../hooks/useMCP';\n\ninterface Task {\n  id: string;\n  title: string;\n  status: string;\n  priority: string;\n}\n\nexport function TaskList() {\n  const { call, loading, error } = useMCP('tasks');\n  const [tasks, setTasks] = useState<Task[]>([]);\n  \n  useEffect(() => {\n    loadTasks();\n  }, []);\n  \n  const loadTasks = async () => {\n    try {\n      const result = await call('list_tasks', {});\n      setTasks(result.tasks);\n    } catch (err) {\n      console.error('Failed to load tasks:', err);\n    }\n  };\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <div>\n      <h2>Tasks</h2>\n      {tasks.map(task => (\n        <div key={task.id}>\n          <h3>{task.title}</h3>\n          <p>Status: {task.status}</p>\n          <p>Priority: {task.priority}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n## Passo 5: Testando com Diferentes LLM Clients\n\n### Teste com OpenAI\n\n```typescript\n// tests/llm-clients/openai.test.ts\nimport { OpenAI } from 'openai';\nimport { MCPClient } from '@modelcontextprotocol/sdk';\n\nasync function testWithOpenAI() {\n  const mcpClient = new MCPClient();\n  mcpClient.registerServer('tasks', 'http://localhost:3001');\n  \n  // Obter tools do MCP\n  const tools = await mcpClient.getToolsForLLM('tasks');\n  \n  const openai = new OpenAI();\n  \n  const response = await openai.chat.completions.create({\n    model: 'gpt-4',\n    messages: [\n      { role: 'user', content: 'Crie uma tarefa chamada \"Implementar MCP\"' }\n    ],\n    tools: tools\n  });\n  \n  // Processar function calls\n  // ...\n}\n```\n\n### Teste com Claude\n\n```typescript\n// tests/llm-clients/claude.test.ts\nimport { Anthropic } from '@anthropic-ai/sdk';\nimport { MCPClient } from '@modelcontextprotocol/sdk';\n\nasync function testWithClaude() {\n  const mcpClient = new MCPClient();\n  mcpClient.registerServer('tasks', 'http://localhost:3001');\n  \n  const tools = await mcpClient.getToolsForLLM('tasks');\n  \n  const anthropic = new Anthropic();\n  \n  const message = await anthropic.messages.create({\n    model: 'claude-3-opus-20240229',\n    max_tokens: 1024,\n    messages: [\n      { role: 'user', content: 'Liste todas as tarefas pendentes' }\n    ],\n    tools: tools\n  });\n  \n  // Processar tool use\n  // ...\n}\n```\n\n## Passo 6: Composição com Outros MCPs\n\n### Integração com MCP de Notificações\n\n```typescript\n// src/composition/notification-integration.ts\nclass TaskNotificationIntegration {\n  constructor(\n    private taskMCP: MCPClient,\n    private notificationMCP: MCPClient\n  ) {}\n  \n  async createTaskWithNotification(taskData: any) {\n    // 1. Criar tarefa\n    const taskResult = await this.taskMCP.call('tasks', 'create_task', taskData);\n    \n    if (taskResult.success) {\n      // 2. Enviar notificação\n      await this.notificationMCP.call('notifications', 'send', {\n        to: taskData.assignee,\n        subject: 'Nova tarefa atribuída',\n        body: `Você foi atribuído à tarefa: ${taskData.title}`\n      });\n    }\n    \n    return taskResult;\n  }\n}\n```\n\n## Passo 7: Deploy em Produção\n\n### Dockerfile\n\n```dockerfile\nFROM node:18-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN npm run build\n\nEXPOSE 3000 3001\n\nCMD [\"npm\", \"start\"]\n```\n\n### docker-compose.yml\n\n```yaml\nversion: '3.8'\n\nservices:\n  mcp-server:\n    build: .\n    ports:\n      - \"3001:3001\"\n    environment:\n      - NODE_ENV=production\n    \n  api-server:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - MCP_SERVER_URL=http://mcp-server:3001\n      - NODE_ENV=production\n    depends_on:\n      - mcp-server\n```\n\n## Conclusão\n\nCriamos um sistema completo:\n\n- ✅ MCP Server funcional\n- ✅ Integração com back-end\n- ✅ Integração com front-end\n- ✅ Testado com diferentes LLMs\n- ✅ Composição com outros MCPs\n- ✅ Pronto para produção\n\nEste projeto demonstra todos os conceitos aprendidos no módulo e serve como base para projetos reais.",
  "resources": [
    {
      "type": "code",
      "title": "Projeto Completo no GitHub",
      "description": "Repositório completo do projeto no GitHub"
    },
    {
      "type": "link",
      "title": "MCP Deployment Guide",
      "description": "Guia de deploy de MCPs em produção"
    },
    {
      "type": "code",
      "title": "MCP Testing Best Practices",
      "description": "Boas práticas de teste para MCPs"
    }
  ]
}

