{
  "id": "module-3-topic-5",
  "title": "Transformando sua empresa em um \"MCP\"",
  "content": "## Introdução\n\nTransformar sua empresa em um \"MCP\" significa expor serviços internos (CRM, billing, suporte, dados de produto) via protocolo MCP, criando uma camada AI-ready que permite que LLMs e agentes interajam com seus sistemas de forma padronizada e segura.\n\nEste tópico explora estratégias para expor serviços internos via MCP e desenhar uma camada AI-ready para toda a stack da empresa.\n\n## Visão Geral da Estratégia\n\n### O Que Significa \"Empresa como MCP\"\n\nEm vez de cada sistema ter integrações customizadas com LLMs, você cria uma camada unificada:\n\n```\nAntes:\nLLM → Integração Custom CRM\nLLM → Integração Custom Billing  \nLLM → Integração Custom Suporte\nLLM → Integração Custom Analytics\n\nDepois:\nLLM → MCP Layer → CRM\nLLM → MCP Layer → Billing\nLLM → MCP Layer → Suporte\nLLM → MCP Layer → Analytics\n```\n\n### Benefícios\n\n- ✅ **Padronização**: Uma interface para todos os serviços\n- ✅ **Reutilização**: Servidores MCP compartilhados\n- ✅ **Segurança**: Governança centralizada\n- ✅ **Flexibilidade**: Fácil adicionar novos serviços\n- ✅ **Futuro-proof**: Funciona com qualquer LLM\n\n## Expondo CRM via MCP\n\n### Exemplo: CRM MCP Server\n\n```typescript\n// src/servers/crm-server.ts\nimport { MCPServer, MCPRequest, MCPResponse } from '@modelcontextprotocol/sdk';\nimport { CRMService } from '../services/crm';\n\nclass CRMMCPServer extends MCPServer {\n  constructor(private crmService: CRMService) {\n    super('crm-server', '1.0.0');\n    \n    this.registerMethod('get_customer', this.getCustomer.bind(this));\n    this.registerMethod('search_customers', this.searchCustomers.bind(this));\n    this.registerMethod('create_customer', this.createCustomer.bind(this));\n    this.registerMethod('update_customer', this.updateCustomer.bind(this));\n    this.registerMethod('get_customer_orders', this.getCustomerOrders.bind(this));\n  }\n  \n  async getCustomer(request: MCPRequest): Promise<MCPResponse> {\n    const { customerId } = request.params;\n    \n    try {\n      const customer = await this.crmService.getCustomer(customerId);\n      \n      return {\n        success: true,\n        data: {\n          id: customer.id,\n          name: customer.name,\n          email: customer.email,\n          phone: customer.phone,\n          status: customer.status,\n          createdAt: customer.createdAt,\n          lastContact: customer.lastContact\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async searchCustomers(request: MCPRequest): Promise<MCPResponse> {\n    const { query, limit = 10 } = request.params;\n    \n    try {\n      const customers = await this.crmService.searchCustomers(query, limit);\n      \n      return {\n        success: true,\n        data: {\n          customers: customers.map(c => ({\n            id: c.id,\n            name: c.name,\n            email: c.email,\n            status: c.status\n          })),\n          count: customers.length\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async createCustomer(request: MCPRequest): Promise<MCPResponse> {\n    const { name, email, phone } = request.params;\n    \n    try {\n      const customer = await this.crmService.createCustomer({\n        name,\n        email,\n        phone\n      });\n      \n      return {\n        success: true,\n        data: {\n          id: customer.id,\n          name: customer.name,\n          email: customer.email\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  // ... outros métodos\n}\n```\n\n## Expondo Billing via MCP\n\n### Exemplo: Billing MCP Server\n\n```typescript\n// src/servers/billing-server.ts\nclass BillingMCPServer extends MCPServer {\n  constructor(private billingService: BillingService) {\n    super('billing-server', '1.0.0');\n    \n    this.registerMethod('get_invoice', this.getInvoice.bind(this));\n    this.registerMethod('get_subscription', this.getSubscription.bind(this));\n    this.registerMethod('get_usage', this.getUsage.bind(this));\n    this.registerMethod('create_invoice', this.createInvoice.bind(this));\n  }\n  \n  async getInvoice(request: MCPRequest): Promise<MCPResponse> {\n    const { invoiceId } = request.params;\n    \n    try {\n      const invoice = await this.billingService.getInvoice(invoiceId);\n      \n      return {\n        success: true,\n        data: {\n          id: invoice.id,\n          customerId: invoice.customerId,\n          amount: invoice.amount,\n          currency: invoice.currency,\n          status: invoice.status,\n          dueDate: invoice.dueDate,\n          items: invoice.items.map(item => ({\n            description: item.description,\n            quantity: item.quantity,\n            price: item.price,\n            total: item.total\n          }))\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async getUsage(request: MCPRequest): Promise<MCPResponse> {\n    const { customerId, startDate, endDate } = request.params;\n    \n    try {\n      const usage = await this.billingService.getUsage(\n        customerId,\n        new Date(startDate),\n        new Date(endDate)\n      );\n      \n      return {\n        success: true,\n        data: {\n          customerId,\n          period: { startDate, endDate },\n          totalUsage: usage.total,\n          breakdown: usage.breakdown\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n}\n```\n\n## Expondo Suporte via MCP\n\n### Exemplo: Support MCP Server\n\n```typescript\n// src/servers/support-server.ts\nclass SupportMCPServer extends MCPServer {\n  constructor(private supportService: SupportService) {\n    super('support-server', '1.0.0');\n    \n    this.registerMethod('get_ticket', this.getTicket.bind(this));\n    this.registerMethod('create_ticket', this.createTicket.bind(this));\n    this.registerMethod('update_ticket', this.updateTicket.bind(this));\n    this.registerMethod('search_tickets', this.searchTickets.bind(this));\n    this.registerMethod('get_ticket_history', this.getTicketHistory.bind(this));\n  }\n  \n  async getTicket(request: MCPRequest): Promise<MCPResponse> {\n    const { ticketId } = request.params;\n    \n    try {\n      const ticket = await this.supportService.getTicket(ticketId);\n      \n      return {\n        success: true,\n        data: {\n          id: ticket.id,\n          subject: ticket.subject,\n          status: ticket.status,\n          priority: ticket.priority,\n          customerId: ticket.customerId,\n          createdAt: ticket.createdAt,\n          updatedAt: ticket.updatedAt,\n          messages: ticket.messages.map(msg => ({\n            author: msg.author,\n            content: msg.content,\n            timestamp: msg.timestamp\n          }))\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async createTicket(request: MCPRequest): Promise<MCPResponse> {\n    const { customerId, subject, description, priority = 'medium' } = request.params;\n    \n    try {\n      const ticket = await this.supportService.createTicket({\n        customerId,\n        subject,\n        description,\n        priority\n      });\n      \n      return {\n        success: true,\n        data: {\n          id: ticket.id,\n          subject: ticket.subject,\n          status: ticket.status\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n}\n```\n\n## Expondo Dados de Produto via MCP\n\n### Exemplo: Product Data MCP Server\n\n```typescript\n// src/servers/product-server.ts\nclass ProductMCPServer extends MCPServer {\n  constructor(private productService: ProductService) {\n    super('product-server', '1.0.0');\n    \n    this.registerMethod('get_product', this.getProduct.bind(this));\n    this.registerMethod('search_products', this.searchProducts.bind(this));\n    this.registerMethod('get_product_inventory', this.getProductInventory.bind(this));\n    this.registerMethod('get_product_reviews', this.getProductReviews.bind(this));\n  }\n  \n  async getProduct(request: MCPRequest): Promise<MCPResponse> {\n    const { productId } = request.params;\n    \n    try {\n      const product = await this.productService.getProduct(productId);\n      \n      return {\n        success: true,\n        data: {\n          id: product.id,\n          name: product.name,\n          description: product.description,\n          price: product.price,\n          currency: product.currency,\n          category: product.category,\n          inStock: product.inStock,\n          inventory: product.inventory,\n          attributes: product.attributes\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n  \n  async searchProducts(request: MCPRequest): Promise<MCPResponse> {\n    const { query, category, minPrice, maxPrice, limit = 20 } = request.params;\n    \n    try {\n      const products = await this.productService.searchProducts({\n        query,\n        category,\n        minPrice,\n        maxPrice,\n        limit\n      });\n      \n      return {\n        success: true,\n        data: {\n          products: products.map(p => ({\n            id: p.id,\n            name: p.name,\n            price: p.price,\n            category: p.category,\n            inStock: p.inStock\n          })),\n          count: products.length\n        }\n      };\n    } catch (error) {\n      return this.handleError(error);\n    }\n  }\n}\n```\n\n## Design de Camada AI-Ready\n\n### Arquitetura da Camada\n\n```typescript\n// src/ai-layer/ai-ready-layer.ts\nclass AIReadyLayer {\n  private servers: Map<string, MCPServer> = new Map();\n  private orchestrator: MCPOrchestrator;\n  private security: SecurityMiddleware;\n  \n  constructor() {\n    this.orchestrator = new MCPOrchestrator();\n    this.security = new SecurityMiddleware(/* ... */);\n  }\n  \n  // Registrar servidores\n  registerServer(name: string, server: MCPServer) {\n    this.servers.set(name, server);\n    this.orchestrator.registerServer(name, server);\n  }\n  \n  // Processar requisição de LLM\n  async processLLMRequest(\n    request: string,\n    context?: any\n  ): Promise<MCPResponse> {\n    // 1. Analisar requisição e determinar quais servidores usar\n    const plan = await this.planExecution(request, context);\n    \n    // 2. Executar plano com segurança\n    const results = await this.orchestrator.executePlan(plan, {\n      security: this.security\n    });\n    \n    // 3. Combinar e formatar resultados\n    return this.formatResponse(results);\n  }\n  \n  // Planejar execução baseado na requisição\n  private async planExecution(\n    request: string,\n    context?: any\n  ): Promise<ExecutionPlan> {\n    // Análise de intenção (pode usar LLM)\n    const intent = await this.analyzeIntent(request);\n    \n    const plan: ExecutionPlan = {\n      steps: []\n    };\n    \n    // Determinar quais servidores e métodos chamar\n    if (intent.includes('customer') || intent.includes('cliente')) {\n      plan.steps.push({\n        server: 'crm',\n        method: 'search_customers',\n        params: { query: request }\n      });\n    }\n    \n    if (intent.includes('invoice') || intent.includes('fatura')) {\n      plan.steps.push({\n        server: 'billing',\n        method: 'get_recent_invoices',\n        params: {}\n      });\n    }\n    \n    // ... mais lógica de planejamento\n    \n    return plan;\n  }\n  \n  private async analyzeIntent(request: string): Promise<string> {\n    // Usar LLM para analisar intenção\n    // ...\n    return request.toLowerCase();\n  }\n}\n\ninterface ExecutionPlan {\n  steps: ExecutionStep[];\n}\n\ninterface ExecutionStep {\n  server: string;\n  method: string;\n  params: Record<string, any>;\n}\n```\n\n### Orquestrador de MCPs\n\n```typescript\n// src/ai-layer/orchestrator.ts\nclass MCPOrchestrator {\n  private servers: Map<string, MCPServer> = new Map();\n  \n  registerServer(name: string, server: MCPServer) {\n    this.servers.set(name, server);\n  }\n  \n  async executePlan(\n    plan: ExecutionPlan,\n    options?: { security?: SecurityMiddleware }\n  ): Promise<MCPResponse[]> {\n    const results: MCPResponse[] = [];\n    \n    for (const step of plan.steps) {\n      const server = this.servers.get(step.server);\n      \n      if (!server) {\n        results.push({\n          success: false,\n          error: { code: 'SERVER_NOT_FOUND', message: `Server ${step.server} not found` }\n        });\n        continue;\n      }\n      \n      // Aplicar segurança se fornecida\n      if (options?.security) {\n        const securityCheck = await options.security.process({\n          server: step.server,\n          method: step.method,\n          params: step.params\n        });\n        \n        if (securityCheck) {\n          results.push(securityCheck);\n          continue;\n        }\n      }\n      \n      // Executar método\n      const result = await server.handleRequest({\n        server: step.server,\n        method: step.method,\n        params: step.params\n      });\n      \n      results.push(result);\n    }\n    \n    return results;\n  }\n}\n```\n\n## Estratégia de Migração\n\n### Fase 1: Identificar Serviços\n\n1. Listar todos os serviços internos\n2. Identificar quais devem ser expostos\n3. Priorizar por importância e uso\n\n### Fase 2: Criar MCP Servers\n\n1. Começar com serviços mais simples\n2. Criar servidores MCP um por um\n3. Testar isoladamente\n\n### Fase 3: Integração Gradual\n\n1. Integrar com LLMs de teste\n2. Validar funcionalidade\n3. Migrar uso gradualmente\n\n### Fase 4: Produção\n\n1. Deploy em produção\n2. Monitoramento\n3. Otimização contínua\n\n## Exemplo Completo: Sistema Empresarial\n\n```typescript\n// src/enterprise-mcp.ts\nclass EnterpriseMCP {\n  private aiLayer: AIReadyLayer;\n  \n  constructor() {\n    this.aiLayer = new AIReadyLayer();\n    \n    // Registrar todos os servidores\n    this.aiLayer.registerServer('crm', new CRMMCPServer(crmService));\n    this.aiLayer.registerServer('billing', new BillingMCPServer(billingService));\n    this.aiLayer.registerServer('support', new SupportMCPServer(supportService));\n    this.aiLayer.registerServer('products', new ProductMCPServer(productService));\n  }\n  \n  // Interface para LLMs\n  async handleLLMRequest(request: string, context?: any) {\n    return await this.aiLayer.processLLMRequest(request, context);\n  }\n  \n  // Interface para agentes\n  async handleAgentRequest(agentRequest: AgentRequest) {\n    // Processar requisição de agente\n    // ...\n  }\n}\n\n// Uso\nconst enterpriseMCP = new EnterpriseMCP();\n\n// LLM pode fazer perguntas em linguagem natural\nconst response = await enterpriseMCP.handleLLMRequest(\n  'Mostre-me os clientes que compraram mais de R$ 1000 este mês'\n);\n```\n\n## Conclusão\n\nTransformar sua empresa em um \"MCP\" envolve:\n\n- **Expor serviços internos**: CRM, billing, suporte, produtos\n- **Criar camada AI-ready**: Interface unificada para LLMs\n- **Orquestração**: Coordenar múltiplos serviços\n- **Segurança**: Governança centralizada\n- **Migração gradual**: Implementação faseada\n\nIsso cria uma base sólida para integração com IA, permitindo que LLMs e agentes interajam com seus sistemas de forma padronizada e segura.",
  "resources": [
    {
      "type": "link",
      "title": "Enterprise MCP Patterns",
      "description": "Padrões de arquitetura para MCPs empresariais"
    },
    {
      "type": "code",
      "title": "MCP Server Templates",
      "description": "Templates para criar servidores MCP empresariais"
    },
    {
      "type": "link",
      "title": "API Design Best Practices",
      "url": "https://restfulapi.net/",
      "description": "Boas práticas de design de APIs"
    }
  ]
}

