{
  "id": "module-3-topic-4",
  "title": "MCP em JavaScript",
  "content": "## Introdução\n\nAgora que entendemos os conceitos e comparações, vamos colocar a mão na massa e aprender como criar e consumir MCPs usando JavaScript/TypeScript. Este tópico cobre desde o setup básico até boas práticas de organização de código e estrutura de projeto.\n\n## Setup do Ambiente\n\n### Instalação\n\n```bash\n# Instalar SDK do MCP\nnpm install @modelcontextprotocol/sdk\n\n# Ou usando yarn\n yarn add @modelcontextprotocol/sdk\n\n# Para TypeScript\nnpm install -D typescript @types/node\n```\n\n### Estrutura de Projeto Inicial\n\n```\nmcp-project/\n├── src/\n│   ├── servers/\n│   │   └── weather-server.ts\n│   ├── clients/\n│   │   └── mcp-client.ts\n│   ├── types/\n│   │   └── mcp.ts\n│   └── utils/\n│       └── helpers.ts\n├── tests/\n│   └── weather-server.test.ts\n├── package.json\n├── tsconfig.json\n└── README.md\n```\n\n## Criando um MCP Server\n\n### Exemplo Básico\n\n```typescript\n// src/servers/weather-server.ts\nimport { MCPServer, MCPRequest, MCPResponse } from '@modelcontextprotocol/sdk';\n\nclass WeatherMCPServer extends MCPServer {\n  constructor() {\n    super('weather-server', '1.0.0');\n    this.registerMethod('get_weather', this.getWeather.bind(this));\n    this.registerMethod('get_forecast', this.getForecast.bind(this));\n  }\n  \n  async getWeather(request: MCPRequest): Promise<MCPResponse> {\n    const { city } = request.params;\n    \n    // Validação\n    if (!city || typeof city !== 'string') {\n      return {\n        success: false,\n        error: {\n          code: 'INVALID_PARAMS',\n          message: 'City parameter is required'\n        }\n      };\n    }\n    \n    try {\n      // Buscar dados do clima\n      const weatherData = await this.fetchWeatherData(city);\n      \n      return {\n        success: true,\n        data: {\n          city,\n          temperature: weatherData.temp,\n          condition: weatherData.condition,\n          humidity: weatherData.humidity,\n          timestamp: new Date().toISOString()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          code: 'FETCH_ERROR',\n          message: error.message\n        }\n      };\n    }\n  }\n  \n  async getForecast(request: MCPRequest): Promise<MCPResponse> {\n    const { city, days = 5 } = request.params;\n    \n    try {\n      const forecast = await this.fetchForecast(city, days);\n      \n      return {\n        success: true,\n        data: {\n          city,\n          forecast: forecast.map(day => ({\n            date: day.date,\n            high: day.high,\n            low: day.low,\n            condition: day.condition\n          }))\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          code: 'FETCH_ERROR',\n          message: error.message\n        }\n      };\n    }\n  }\n  \n  private async fetchWeatherData(city: string) {\n    // Implementação de busca de dados\n    const response = await fetch(`https://api.weather.com/v1/current?city=${city}`);\n    return await response.json();\n  }\n  \n  private async fetchForecast(city: string, days: number) {\n    // Implementação de busca de previsão\n    const response = await fetch(`https://api.weather.com/v1/forecast?city=${city}&days=${days}`);\n    return await response.json();\n  }\n}\n\n// Inicializar servidor\nconst server = new WeatherMCPServer();\nserver.start(3000);\n```\n\n### Server com Validação e Middleware\n\n```typescript\n// src/servers/advanced-server.ts\nimport { MCPServer, MCPRequest, MCPResponse, MCPMiddleware } from '@modelcontextprotocol/sdk';\n\nclass AdvancedMCPServer extends MCPServer {\n  constructor() {\n    super('advanced-server', '1.0.0');\n    \n    // Adicionar middlewares\n    this.use(this.loggingMiddleware.bind(this));\n    this.use(this.authMiddleware.bind(this));\n    this.use(this.rateLimitMiddleware.bind(this));\n    \n    // Registrar métodos\n    this.registerMethod('get_data', this.getData.bind(this));\n  }\n  \n  // Middleware de logging\n  private async loggingMiddleware(\n    request: MCPRequest,\n    next: () => Promise<MCPResponse>\n  ): Promise<MCPResponse> {\n    const startTime = Date.now();\n    console.log(`[${new Date().toISOString()}] ${request.method} - ${request.server}`);\n    \n    const response = await next();\n    \n    const duration = Date.now() - startTime;\n    console.log(`[${new Date().toISOString()}] Completed in ${duration}ms`);\n    \n    return response;\n  }\n  \n  // Middleware de autenticação\n  private async authMiddleware(\n    request: MCPRequest,\n    next: () => Promise<MCPResponse>\n  ): Promise<MCPResponse> {\n    const token = request.metadata?.authToken;\n    \n    if (!token || !this.validateToken(token)) {\n      return {\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: 'Invalid or missing authentication token'\n        }\n      };\n    }\n    \n    return await next();\n  }\n  \n  // Middleware de rate limiting\n  private async rateLimitMiddleware(\n    request: MCPRequest,\n    next: () => Promise<MCPResponse>\n  ): Promise<MCPResponse> {\n    const clientId = request.metadata?.clientId;\n    \n    if (!this.checkRateLimit(clientId)) {\n      return {\n        success: false,\n        error: {\n          code: 'RATE_LIMIT_EXCEEDED',\n          message: 'Too many requests'\n        }\n      };\n    }\n    \n    return await next();\n  }\n  \n  private validateToken(token: string): boolean {\n    // Implementação de validação\n    return true;\n  }\n  \n  private checkRateLimit(clientId: string): boolean {\n    // Implementação de rate limiting\n    return true;\n  }\n  \n  async getData(request: MCPRequest): Promise<MCPResponse> {\n    // Lógica do método\n    return { success: true, data: {} };\n  }\n}\n```\n\n## Criando um MCP Client\n\n### Client Básico\n\n```typescript\n// src/clients/mcp-client.ts\nimport { MCPClient, MCPRequest, MCPResponse } from '@modelcontextprotocol/sdk';\n\nclass MCPClientImpl extends MCPClient {\n  private servers: Map<string, string> = new Map();\n  \n  constructor() {\n    super();\n  }\n  \n  // Registrar servidor MCP\n  registerServer(name: string, url: string) {\n    this.servers.set(name, url);\n  }\n  \n  // Chamar método em servidor MCP\n  async call(\n    server: string,\n    method: string,\n    params: Record<string, any>,\n    options?: { context?: any; metadata?: any }\n  ): Promise<MCPResponse> {\n    const serverUrl = this.servers.get(server);\n    \n    if (!serverUrl) {\n      throw new Error(`Server ${server} not found`);\n    }\n    \n    const request: MCPRequest = {\n      server,\n      method,\n      params,\n      context: options?.context,\n      metadata: options?.metadata\n    };\n    \n    const response = await fetch(serverUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(request)\n    });\n    \n    return await response.json();\n  }\n  \n  // Descobrir capacidades de um servidor\n  async discover(server: string): Promise<string[]> {\n    const response = await this.call(server, '_discover', {});\n    return response.data?.methods || [];\n  }\n}\n\n// Uso\nconst client = new MCPClientImpl();\nclient.registerServer('weather', 'http://localhost:3000');\n\nconst weather = await client.call('weather', 'get_weather', { city: 'São Paulo' });\nconsole.log(weather.data);\n```\n\n### Client com Suporte a Múltiplos LLMs\n\n```typescript\n// src/clients/llm-aware-client.ts\nimport { MCPClient } from '@modelcontextprotocol/sdk';\n\ntype LLMProvider = 'openai' | 'anthropic' | 'google';\n\nclass LLMAwareMCPClient extends MCPClient {\n  private currentLLM: LLMProvider = 'openai';\n  private adapters: Map<LLMProvider, LLMAdapter> = new Map();\n  \n  constructor() {\n    super();\n    \n    // Registrar adapters para cada LLM\n    this.adapters.set('openai', new OpenAIAdapter());\n    this.adapters.set('anthropic', new AnthropicAdapter());\n    this.adapters.set('google', new GoogleAdapter());\n  }\n  \n  setLLM(provider: LLMProvider) {\n    this.currentLLM = provider;\n  }\n  \n  async call(server: string, method: string, params: Record<string, any>) {\n    // Fazer chamada MCP\n    const mcpResponse = await super.call(server, method, params);\n    \n    // Traduzir resposta para formato do LLM atual\n    const adapter = this.adapters.get(this.currentLLM);\n    return adapter.translate(mcpResponse);\n  }\n  \n  // Expor como tools para LLM\n  async getToolsForLLM(server: string): Promise<any[]> {\n    const capabilities = await this.discover(server);\n    const adapter = this.adapters.get(this.currentLLM);\n    \n    return adapter.formatTools(capabilities);\n  }\n}\n\n// Adapters para cada LLM\ninterface LLMAdapter {\n  translate(response: MCPResponse): any;\n  formatTools(capabilities: string[]): any[];\n}\n\nclass OpenAIAdapter implements LLMAdapter {\n  translate(response: MCPResponse) {\n    // Traduzir para formato OpenAI\n    return response.data;\n  }\n  \n  formatTools(capabilities: string[]) {\n    // Formato de functions para OpenAI\n    return capabilities.map(method => ({\n      name: method,\n      description: `Call ${method} on MCP server`,\n      parameters: { type: 'object', properties: {} }\n    }));\n  }\n}\n\nclass AnthropicAdapter implements LLMAdapter {\n  translate(response: MCPResponse) {\n    // Traduzir para formato Anthropic\n    return response.data;\n  }\n  \n  formatTools(capabilities: string[]) {\n    // Formato de tools para Anthropic\n    return capabilities.map(method => ({\n      name: method,\n      description: `Call ${method} on MCP server`,\n      input_schema: { type: 'object', properties: {} }\n    }));\n  }\n}\n```\n\n## Boas Práticas de Organização\n\n### Estrutura de Projeto Recomendada\n\n```\nproject/\n├── src/\n│   ├── servers/\n│   │   ├── index.ts\n│   │   ├── weather-server.ts\n│   │   ├── database-server.ts\n│   │   └── crm-server.ts\n│   ├── clients/\n│   │   ├── index.ts\n│   │   ├── mcp-client.ts\n│   │   └── llm-client.ts\n│   ├── types/\n│   │   ├── mcp.ts\n│   │   └── common.ts\n│   ├── utils/\n│   │   ├── validation.ts\n│   │   ├── errors.ts\n│   │   └── logging.ts\n│   ├── middleware/\n│   │   ├── auth.ts\n│   │   ├── rate-limit.ts\n│   │   └── logging.ts\n│   └── config/\n│       └── index.ts\n├── tests/\n│   ├── servers/\n│   ├── clients/\n│   └── integration/\n├── package.json\n├── tsconfig.json\n└── README.md\n```\n\n### Separação de Responsabilidades\n\n```typescript\n// src/servers/base-server.ts\n// Classe base para todos os servidores\nabstract class BaseMCPServer extends MCPServer {\n  protected logger: Logger;\n  protected validator: Validator;\n  \n  constructor(name: string, version: string) {\n    super(name, version);\n    this.logger = new Logger(name);\n    this.validator = new Validator();\n  }\n  \n  protected validateParams(params: any, schema: Schema): boolean {\n    return this.validator.validate(params, schema);\n  }\n  \n  protected log(level: string, message: string, data?: any) {\n    this.logger.log(level, message, data);\n  }\n}\n\n// src/servers/weather-server.ts\n// Servidor específico herda da base\nclass WeatherMCPServer extends BaseMCPServer {\n  constructor() {\n    super('weather-server', '1.0.0');\n  }\n  \n  // Implementação específica\n}\n```\n\n### Tratamento de Erros\n\n```typescript\n// src/utils/errors.ts\nexport class MCPError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'MCPError';\n  }\n}\n\nexport class ValidationError extends MCPError {\n  constructor(message: string, details?: any) {\n    super('VALIDATION_ERROR', message, details);\n  }\n}\n\nexport class ServerError extends MCPError {\n  constructor(message: string, details?: any) {\n    super('SERVER_ERROR', message, details);\n  }\n}\n\n// Uso\nasync getWeather(request: MCPRequest): Promise<MCPResponse> {\n  try {\n    if (!request.params.city) {\n      throw new ValidationError('City parameter is required');\n    }\n    \n    const data = await this.fetchWeather(request.params.city);\n    return { success: true, data };\n  } catch (error) {\n    if (error instanceof MCPError) {\n      return {\n        success: false,\n        error: {\n          code: error.code,\n          message: error.message,\n          details: error.details\n        }\n      };\n    }\n    \n    // Erro não esperado\n    this.log('error', 'Unexpected error', error);\n    return {\n      success: false,\n      error: {\n        code: 'INTERNAL_ERROR',\n        message: 'An unexpected error occurred'\n      }\n    };\n  }\n}\n```\n\n### Configuração e Ambiente\n\n```typescript\n// src/config/index.ts\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const config = {\n  mcp: {\n    port: parseInt(process.env.MCP_PORT || '3000'),\n    host: process.env.MCP_HOST || 'localhost'\n  },\n  servers: {\n    weather: {\n      url: process.env.WEATHER_API_URL || '',\n      apiKey: process.env.WEATHER_API_KEY || ''\n    },\n    database: {\n      connectionString: process.env.DATABASE_URL || ''\n    }\n  },\n  auth: {\n    secret: process.env.AUTH_SECRET || '',\n    tokenExpiry: process.env.TOKEN_EXPIRY || '24h'\n  }\n};\n```\n\n## Testes\n\n### Testes Unitários\n\n```typescript\n// tests/servers/weather-server.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { WeatherMCPServer } from '../../src/servers/weather-server';\n\ndescribe('WeatherMCPServer', () => {\n  let server: WeatherMCPServer;\n  \n  beforeEach(() => {\n    server = new WeatherMCPServer();\n  });\n  \n  it('should get weather for a valid city', async () => {\n    const response = await server.getWeather({\n      server: 'weather',\n      method: 'get_weather',\n      params: { city: 'São Paulo' }\n    });\n    \n    expect(response.success).toBe(true);\n    expect(response.data).toHaveProperty('city');\n    expect(response.data).toHaveProperty('temperature');\n  });\n  \n  it('should return error for missing city', async () => {\n    const response = await server.getWeather({\n      server: 'weather',\n      method: 'get_weather',\n      params: {}\n    });\n    \n    expect(response.success).toBe(false);\n    expect(response.error?.code).toBe('INVALID_PARAMS');\n  });\n});\n```\n\n### Testes de Integração\n\n```typescript\n// tests/integration/client-server.test.ts\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { WeatherMCPServer } from '../../src/servers/weather-server';\nimport { MCPClientImpl } from '../../src/clients/mcp-client';\n\ndescribe('MCP Client-Server Integration', () => {\n  let server: WeatherMCPServer;\n  let client: MCPClientImpl;\n  \n  beforeAll(async () => {\n    server = new WeatherMCPServer();\n    await server.start(3000);\n    \n    client = new MCPClientImpl();\n    client.registerServer('weather', 'http://localhost:3000');\n  });\n  \n  afterAll(async () => {\n    await server.stop();\n  });\n  \n  it('should communicate between client and server', async () => {\n    const response = await client.call('weather', 'get_weather', {\n      city: 'São Paulo'\n    });\n    \n    expect(response.success).toBe(true);\n  });\n});\n```\n\n## Exemplo Completo: Projeto Estruturado\n\n```typescript\n// src/index.ts\nimport { WeatherMCPServer } from './servers/weather-server';\nimport { DatabaseMCPServer } from './servers/database-server';\nimport { LLMAwareMCPClient } from './clients/llm-aware-client';\nimport { config } from './config';\n\nasync function main() {\n  // Inicializar servidores\n  const weatherServer = new WeatherMCPServer();\n  const databaseServer = new DatabaseMCPServer();\n  \n  await weatherServer.start(config.mcp.port);\n  await databaseServer.start(config.mcp.port + 1);\n  \n  // Inicializar client\n  const client = new LLMAwareMCPClient();\n  client.registerServer('weather', `http://localhost:${config.mcp.port}`);\n  client.registerServer('database', `http://localhost:${config.mcp.port + 1}`);\n  \n  // Configurar LLM\n  client.setLLM('openai');\n  \n  // Usar\n  const weather = await client.call('weather', 'get_weather', {\n    city: 'São Paulo'\n  });\n  \n  console.log('Weather:', weather.data);\n}\n\nmain().catch(console.error);\n```\n\n## Conclusão\n\nCriar e consumir MCPs em JavaScript/TypeScript envolve:\n\n- **Estrutura clara**: Separação de responsabilidades\n- **Type safety**: TypeScript para segurança de tipos\n- **Tratamento de erros**: Erros bem definidos e tratados\n- **Testes**: Cobertura adequada de testes\n- **Configuração**: Ambiente e configuração bem organizados\n- **Boas práticas**: Código limpo e manutenível\n\nNo próximo tópico, vamos explorar como transformar sua empresa em um \"MCP\", expondo serviços internos de forma padronizada.",
  "resources": [
    {
      "type": "link",
      "title": "MCP JavaScript SDK",
      "url": "https://github.com/modelcontextprotocol/js-sdk",
      "description": "SDK oficial do MCP para JavaScript/TypeScript"
    },
    {
      "type": "code",
      "title": "MCP Server Examples",
      "url": "https://github.com/modelcontextprotocol/servers/tree/main/src",
      "description": "Exemplos de servidores MCP em JavaScript/TypeScript"
    },
    {
      "type": "link",
      "title": "TypeScript Best Practices",
      "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html",
      "description": "Boas práticas de TypeScript"
    },
    {
      "type": "code",
      "title": "MCP Testing Guide",
      "description": "Guia de testes para MCPs"
    }
  ]
}

